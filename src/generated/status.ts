// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "status.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EventHeader } from "./orion_common";
import { ReplyHeader } from "./orion_common";
import { RequestFilter } from "./orion_common";
import { RequestHeader } from "./orion_common";
import { ObjectType } from "./orion_common";
import { BaseInformation } from "./orion_common";
/**
 * @generated from protobuf message Status
 */
export interface Status {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: ObjectType allowedForType = 2
     */
    allowedForType: ObjectType;
    /**
     * @generated from protobuf field: bool isUsable = 3
     */
    isUsable: boolean;
}
/**
 * @generated from protobuf message AddStatusRequest
 */
export interface AddStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message UpdateStatusRequest
 */
export interface UpdateStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message DeleteStatusRequest
 */
export interface DeleteStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string statusId = 2
     */
    statusId: string;
}
/**
 * @generated from protobuf message GetStatusRequest
 */
export interface GetStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message GetStatusReply
 */
export interface GetStatusReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated Status status = 2
     */
    status: Status[];
}
/**
 * @generated from protobuf message StatusSavedEvent
 */
export interface StatusSavedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message StatusDeletedEvent
 */
export interface StatusDeletedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("Status", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "allowedForType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 3, name: "isUsable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedForType = 0;
        message.isUsable = false;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* ObjectType allowedForType */ 2:
                    message.allowedForType = reader.int32();
                    break;
                case /* bool isUsable */ 3:
                    message.isUsable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ObjectType allowedForType = 2; */
        if (message.allowedForType !== 0)
            writer.tag(2, WireType.Varint).int32(message.allowedForType);
        /* bool isUsable = 3; */
        if (message.isUsable !== false)
            writer.tag(3, WireType.Varint).bool(message.isUsable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddStatusRequest$Type extends MessageType<AddStatusRequest> {
    constructor() {
        super("AddStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<AddStatusRequest>): AddStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddStatusRequest): AddStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddStatusRequest
 */
export const AddStatusRequest = new AddStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusRequest$Type extends MessageType<UpdateStatusRequest> {
    constructor() {
        super("UpdateStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusRequest>): UpdateStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusRequest): UpdateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateStatusRequest
 */
export const UpdateStatusRequest = new UpdateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRequest$Type extends MessageType<DeleteStatusRequest> {
    constructor() {
        super("DeleteStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "statusId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusRequest>): DeleteStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRequest): DeleteStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string statusId */ 2:
                    message.statusId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string statusId = 2; */
        if (message.statusId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.statusId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteStatusRequest
 */
export const DeleteStatusRequest = new DeleteStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("GetStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusReply$Type extends MessageType<GetStatusReply> {
    constructor() {
        super("GetStatusReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "status", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusReply>): GetStatusReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusReply): GetStatusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated Status status */ 2:
                    message.status.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Status status = 2; */
        for (let i = 0; i < message.status.length; i++)
            Status.internalBinaryWrite(message.status[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusReply
 */
export const GetStatusReply = new GetStatusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusSavedEvent$Type extends MessageType<StatusSavedEvent> {
    constructor() {
        super("StatusSavedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StatusSavedEvent>): StatusSavedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusSavedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusSavedEvent): StatusSavedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusSavedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusSavedEvent
 */
export const StatusSavedEvent = new StatusSavedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusDeletedEvent$Type extends MessageType<StatusDeletedEvent> {
    constructor() {
        super("StatusDeletedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusDeletedEvent>): StatusDeletedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<StatusDeletedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusDeletedEvent): StatusDeletedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusDeletedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusDeletedEvent
 */
export const StatusDeletedEvent = new StatusDeletedEvent$Type();
