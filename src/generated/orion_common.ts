// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "orion_common.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Heartbeat
 */
export interface Heartbeat {
    /**
     * @generated from protobuf field: int64 currentTime = 1
     */
    currentTime: bigint;
    /**
     * @generated from protobuf field: int64 startedTime = 2
     */
    startedTime: bigint;
    /**
     * @generated from protobuf field: string appName = 3
     */
    appName: string;
    /**
     * @generated from protobuf field: string appVersion = 4
     */
    appVersion: string;
    /**
     * @generated from protobuf field: string hostAddress = 5
     */
    hostAddress: string;
    /**
     * @generated from protobuf field: int32 port = 6
     */
    port: number;
    /**
     * @generated from protobuf field: int32 numGoRoutines = 7
     */
    numGoRoutines: number;
    /**
     * @generated from protobuf field: int32 numCpu = 8
     */
    numCpu: number;
    /**
     * @generated from protobuf field: string goOs = 9
     */
    goOs: string;
    /**
     * @generated from protobuf field: string goArch = 10
     */
    goArch: string;
    /**
     * @generated from protobuf field: string goVersion = 11
     */
    goVersion: string;
    /**
     * @generated from protobuf field: uint64 allocBytes = 12
     */
    allocBytes: bigint;
    /**
     * @generated from protobuf field: uint64 totalAllocBytes = 13
     */
    totalAllocBytes: bigint;
    /**
     * @generated from protobuf field: uint64 sysBytes = 14
     */
    sysBytes: bigint;
    /**
     * @generated from protobuf field: uint64 lookups = 15
     */
    lookups: bigint;
}
/**
 * @generated from protobuf message BaseInformation
 */
export interface BaseInformation {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // @gotags: json:"name"
    /**
     * @generated from protobuf field: optional string description = 2
     */
    description?: string;
    /**
     * @generated from protobuf field: int64 createdDate = 3
     */
    createdDate: bigint; // @gotags: db:"created_date"
    /**
     * @generated from protobuf field: string createdBy = 4
     */
    createdBy: string; // @gotags: db:"created_by"
    /**
     * @generated from protobuf field: optional int64 lastUpdatedDate = 5
     */
    lastUpdatedDate?: bigint; // @gotags: db:"last_updated_date"
    /**
     * @generated from protobuf field: optional string lastUpdatedBy = 6
     */
    lastUpdatedBy?: string; // @gotags: db:"last_updated_by"
    /**
     * @generated from protobuf field: optional int64 deletedDate = 7
     */
    deletedDate?: bigint; // @gotags: db:"deleted_date"
    /**
     * @generated from protobuf field: optional string deletedBy = 8
     */
    deletedBy?: string; // @gotags: db:"deleted_by"
    /**
     * @generated from protobuf field: int32 version = 9
     */
    version: number;
    /**
     * @generated from protobuf field: bool obsolete = 10
     */
    obsolete: boolean;
    /**
     * @generated from protobuf field: Uuid id = 11
     */
    id?: Uuid;
    /**
     * @generated from protobuf field: bool active = 12
     */
    active: boolean;
    /**
     * @generated from protobuf field: optional int64 checkedOutDate = 13
     */
    checkedOutDate?: bigint; // @gotags: db:"checked_out_date"
    /**
     * @generated from protobuf field: optional string checkedOutBy = 14
     */
    checkedOutBy?: string; // @gotags: db:"checked_out_by"
    /**
     * @generated from protobuf field: ObjectType objectType = 15
     */
    objectType: ObjectType; // @gotags: db:"object_type"
}
/**
 * @generated from protobuf message Uuid
 */
export interface Uuid {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
}
/**
 * @generated from protobuf message Comment
 */
export interface Comment {
    /**
     * @generated from protobuf field: Uuid id = 1
     */
    id?: Uuid;
    /**
     * @generated from protobuf field: string comment = 2
     */
    comment: string;
    /**
     * @generated from protobuf field: int64 createdDate = 3
     */
    createdDate: bigint;
    /**
     * @generated from protobuf field: string createdBy = 4
     */
    createdBy: string;
    /**
     * @generated from protobuf field: optional string service = 5
     */
    service?: string;
}
/**
 * @generated from protobuf message EventHeader
 */
export interface EventHeader {
    /**
     * @generated from protobuf field: string senderAddress = 1
     */
    senderAddress: string;
    /**
     * @generated from protobuf field: string senderId = 2
     */
    senderId: string;
    /**
     * @generated from protobuf field: string user = 3
     */
    user: string;
    /**
     * @generated from protobuf field: ObjectType objectType = 4
     */
    objectType: ObjectType;
    /**
     * @generated from protobuf field: int64 eventDate = 5
     */
    eventDate: bigint;
    /**
     * @generated from protobuf field: string senderApp = 6
     */
    senderApp: string;
    /**
     * @generated from protobuf field: EventType eventType = 7
     */
    eventType: EventType;
}
/**
 * @generated from protobuf message RequestHeader
 */
export interface RequestHeader {
    /**
     * @generated from protobuf field: string senderId = 2
     */
    senderId: string;
    /**
     * @generated from protobuf field: string user = 3
     */
    user: string;
    /**
     * @generated from protobuf field: optional Comment comment = 4
     */
    comment?: Comment;
}
/**
 * @generated from protobuf message ReplyHeader
 */
export interface ReplyHeader {
    /**
     * @generated from protobuf field: string senderId = 2
     */
    senderId: string;
    /**
     * @generated from protobuf field: string errorMessage = 3
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: bool successful = 4
     */
    successful: boolean;
    /**
     * @generated from protobuf field: int32 errorCode = 5
     */
    errorCode: number;
    /**
     * @generated from protobuf field: int64 timeStamp = 6
     */
    timeStamp: bigint;
    /**
     * @generated from protobuf field: string service = 7
     */
    service: string;
}
/**
 * @generated from protobuf message SaveReply
 */
export interface SaveReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: string uuid = 2
     */
    uuid: string;
    /**
     * @generated from protobuf field: ObjectType objectType = 3
     */
    objectType: ObjectType;
}
/**
 * @generated from protobuf message RequestFilter
 */
export interface RequestFilter {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
    /**
     * @generated from protobuf field: FilterConnector connector = 3
     */
    connector: FilterConnector;
    /**
     * @generated from protobuf field: FilterDataType dataType = 4
     */
    dataType: FilterDataType;
    /**
     * @generated from protobuf field: FilterFunction function = 5
     */
    function: FilterFunction;
}
/**
 * @generated from protobuf message RequestFilterDescriptor
 */
export interface RequestFilterDescriptor {
    /**
     * @generated from protobuf field: ObjectType objectType = 1
     */
    objectType: ObjectType;
    /**
     * @generated from protobuf field: string key = 2
     */
    key: string;
    /**
     * @generated from protobuf field: FilterDataType dataType = 3
     */
    dataType: FilterDataType;
    /**
     * @generated from protobuf field: int64 createdDate = 4
     */
    createdDate: bigint;
    /**
     * @generated from protobuf field: string createdBy = 5
     */
    createdBy: string;
    /**
     * @generated from protobuf field: optional int64 lastUpdatedDate = 6
     */
    lastUpdatedDate?: bigint;
    /**
     * @generated from protobuf field: optional string lastUpdatedBy = 7
     */
    lastUpdatedBy?: string;
    /**
     * @generated from protobuf field: Uuid id = 8
     */
    id?: Uuid;
    /**
     * @generated from protobuf field: bool active = 9
     */
    active: boolean;
    /**
     * @generated from protobuf field: bool obsolete = 10
     */
    obsolete: boolean;
}
/**
 * @generated from protobuf message Metric
 */
export interface Metric {
    /**
     * @generated from protobuf field: string endPoint = 1
     */
    endPoint: string;
    /**
     * @generated from protobuf field: bool successful = 2
     */
    successful: boolean;
    /**
     * @generated from protobuf field: int32 httpStatus = 3
     */
    httpStatus: number;
    /**
     * @generated from protobuf field: int64 startedTime = 4
     */
    startedTime: bigint;
    /**
     * @generated from protobuf field: int64 endTime = 5
     */
    endTime: bigint;
    /**
     * @generated from protobuf field: Uuid id = 6
     */
    id?: Uuid;
    /**
     * @generated from protobuf field: optional string errorMessage = 7
     */
    errorMessage?: string;
    /**
     * @generated from protobuf field: int32 errorCode = 8
     */
    errorCode: number;
}
/**
 * @generated from protobuf message MetricOverview
 */
export interface MetricOverview {
    /**
     * @generated from protobuf field: string endPoint = 1
     */
    endPoint: string;
    /**
     * @generated from protobuf field: int32 successfulCount = 2
     */
    successfulCount: number;
    /**
     * @generated from protobuf field: int32 errorCount = 3
     */
    errorCount: number;
    /**
     * @generated from protobuf field: float averageDuration = 4
     */
    averageDuration: number;
    /**
     * @generated from protobuf field: int32 minDuration = 5
     */
    minDuration: number;
    /**
     * @generated from protobuf field: int32 maxDuration = 6
     */
    maxDuration: number;
}
/**
 * @generated from protobuf message AppGroup
 */
export interface AppGroup {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: optional string icon = 2
     */
    icon?: string;
    /**
     * @generated from protobuf field: repeated AppNavigationItem navigationItems = 3
     */
    navigationItems: AppNavigationItem[];
}
/**
 * @generated from protobuf message AppNavigationItem
 */
export interface AppNavigationItem {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: optional string icon = 2
     */
    icon?: string;
    /**
     * @generated from protobuf field: string route = 3
     */
    route: string;
    /**
     * @generated from protobuf field: string component = 4
     */
    component: string;
}
/**
 * @generated from protobuf enum ObjectType
 */
export enum ObjectType {
    /**
     * @generated from protobuf enum value: OT_UNKNOWN = 0;
     */
    OT_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: OT_USER = 1;
     */
    OT_USER = 1,
    /**
     * @generated from protobuf enum value: OT_SPECIFICATION = 2;
     */
    OT_SPECIFICATION = 2,
    /**
     * @generated from protobuf enum value: OT_STATUS = 3;
     */
    OT_STATUS = 3,
    /**
     * @generated from protobuf enum value: OT_TRANSLATION = 4;
     */
    OT_TRANSLATION = 4,
    /**
     * @generated from protobuf enum value: OT_DIALOG = 5;
     */
    OT_DIALOG = 5,
    /**
     * @generated from protobuf enum value: OT_CONFIG_PARAMETER = 6;
     */
    OT_CONFIG_PARAMETER = 6,
    /**
     * @generated from protobuf enum value: OT_REQUEST_FILTER_DESCRIPTOR = 7;
     */
    OT_REQUEST_FILTER_DESCRIPTOR = 7,
    /**
     * @generated from protobuf enum value: OT_STATUS_TRANSITION_RULE = 8;
     */
    OT_STATUS_TRANSITION_RULE = 8
}
/**
 * @generated from protobuf enum FilterDataType
 */
export enum FilterDataType {
    /**
     * @generated from protobuf enum value: FDT_UNKNOWN = 0;
     */
    FDT_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: FDT_STRING = 1;
     */
    FDT_STRING = 1,
    /**
     * @generated from protobuf enum value: FDT_NUMERIC = 2;
     */
    FDT_NUMERIC = 2,
    /**
     * @generated from protobuf enum value: FDT_BOOL = 3;
     */
    FDT_BOOL = 3
}
/**
 * @generated from protobuf enum FilterFunction
 */
export enum FilterFunction {
    /**
     * @generated from protobuf enum value: FF_UNKNOWN = 0;
     */
    FF_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: FF_EQUALS = 1;
     */
    FF_EQUALS = 1,
    /**
     * @generated from protobuf enum value: FF_NOT_EQUALS = 2;
     */
    FF_NOT_EQUALS = 2,
    /**
     * @generated from protobuf enum value: FF_LIKE = 3;
     */
    FF_LIKE = 3,
    /**
     * @generated from protobuf enum value: FF_NOT_LIKE = 4;
     */
    FF_NOT_LIKE = 4,
    /**
     * @generated from protobuf enum value: FF_GREATER_THAN = 5;
     */
    FF_GREATER_THAN = 5,
    /**
     * @generated from protobuf enum value: FF_GREATER_THAN_EQUALS = 6;
     */
    FF_GREATER_THAN_EQUALS = 6,
    /**
     * @generated from protobuf enum value: FF_LESS_THAN = 7;
     */
    FF_LESS_THAN = 7,
    /**
     * @generated from protobuf enum value: FF_LESS_THAN_EQUALS = 8;
     */
    FF_LESS_THAN_EQUALS = 8
}
/**
 * @generated from protobuf enum FilterConnector
 */
export enum FilterConnector {
    /**
     * @generated from protobuf enum value: FC_UNKNOWN = 0;
     */
    FC_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: FC_AND = 1;
     */
    FC_AND = 1,
    /**
     * @generated from protobuf enum value: FC_OR = 2;
     */
    FC_OR = 2
}
/**
 * @generated from protobuf enum EventType
 */
export enum EventType {
    /**
     * @generated from protobuf enum value: ET_UNKNOWN = 0;
     */
    ET_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: ET_OBJECT_ADDED = 1;
     */
    ET_OBJECT_ADDED = 1,
    /**
     * @generated from protobuf enum value: ET_OBJECT_UPDATED = 2;
     */
    ET_OBJECT_UPDATED = 2,
    /**
     * @generated from protobuf enum value: ET_OBJECT_DELETED = 3;
     */
    ET_OBJECT_DELETED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Heartbeat$Type extends MessageType<Heartbeat> {
    constructor() {
        super("Heartbeat", [
            { no: 1, name: "currentTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "appVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hostAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "numGoRoutines", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "numCpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "goOs", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "goArch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "goVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "allocBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "totalAllocBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "sysBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "lookups", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Heartbeat>): Heartbeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentTime = 0n;
        message.startedTime = 0n;
        message.appName = "";
        message.appVersion = "";
        message.hostAddress = "";
        message.port = 0;
        message.numGoRoutines = 0;
        message.numCpu = 0;
        message.goOs = "";
        message.goArch = "";
        message.goVersion = "";
        message.allocBytes = 0n;
        message.totalAllocBytes = 0n;
        message.sysBytes = 0n;
        message.lookups = 0n;
        if (value !== undefined)
            reflectionMergePartial<Heartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heartbeat): Heartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 currentTime */ 1:
                    message.currentTime = reader.int64().toBigInt();
                    break;
                case /* int64 startedTime */ 2:
                    message.startedTime = reader.int64().toBigInt();
                    break;
                case /* string appName */ 3:
                    message.appName = reader.string();
                    break;
                case /* string appVersion */ 4:
                    message.appVersion = reader.string();
                    break;
                case /* string hostAddress */ 5:
                    message.hostAddress = reader.string();
                    break;
                case /* int32 port */ 6:
                    message.port = reader.int32();
                    break;
                case /* int32 numGoRoutines */ 7:
                    message.numGoRoutines = reader.int32();
                    break;
                case /* int32 numCpu */ 8:
                    message.numCpu = reader.int32();
                    break;
                case /* string goOs */ 9:
                    message.goOs = reader.string();
                    break;
                case /* string goArch */ 10:
                    message.goArch = reader.string();
                    break;
                case /* string goVersion */ 11:
                    message.goVersion = reader.string();
                    break;
                case /* uint64 allocBytes */ 12:
                    message.allocBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 totalAllocBytes */ 13:
                    message.totalAllocBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 sysBytes */ 14:
                    message.sysBytes = reader.uint64().toBigInt();
                    break;
                case /* uint64 lookups */ 15:
                    message.lookups = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 currentTime = 1; */
        if (message.currentTime !== 0n)
            writer.tag(1, WireType.Varint).int64(message.currentTime);
        /* int64 startedTime = 2; */
        if (message.startedTime !== 0n)
            writer.tag(2, WireType.Varint).int64(message.startedTime);
        /* string appName = 3; */
        if (message.appName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appName);
        /* string appVersion = 4; */
        if (message.appVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.appVersion);
        /* string hostAddress = 5; */
        if (message.hostAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hostAddress);
        /* int32 port = 6; */
        if (message.port !== 0)
            writer.tag(6, WireType.Varint).int32(message.port);
        /* int32 numGoRoutines = 7; */
        if (message.numGoRoutines !== 0)
            writer.tag(7, WireType.Varint).int32(message.numGoRoutines);
        /* int32 numCpu = 8; */
        if (message.numCpu !== 0)
            writer.tag(8, WireType.Varint).int32(message.numCpu);
        /* string goOs = 9; */
        if (message.goOs !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.goOs);
        /* string goArch = 10; */
        if (message.goArch !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.goArch);
        /* string goVersion = 11; */
        if (message.goVersion !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.goVersion);
        /* uint64 allocBytes = 12; */
        if (message.allocBytes !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.allocBytes);
        /* uint64 totalAllocBytes = 13; */
        if (message.totalAllocBytes !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.totalAllocBytes);
        /* uint64 sysBytes = 14; */
        if (message.sysBytes !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.sysBytes);
        /* uint64 lookups = 15; */
        if (message.lookups !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.lookups);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Heartbeat
 */
export const Heartbeat = new Heartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BaseInformation$Type extends MessageType<BaseInformation> {
    constructor() {
        super("BaseInformation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "createdDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lastUpdatedDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "lastUpdatedBy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "deletedDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "deletedBy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "obsolete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "id", kind: "message", T: () => Uuid },
            { no: 12, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "checkedOutDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "checkedOutBy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] }
        ]);
    }
    create(value?: PartialMessage<BaseInformation>): BaseInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.createdDate = 0n;
        message.createdBy = "";
        message.version = 0;
        message.obsolete = false;
        message.active = false;
        message.objectType = 0;
        if (value !== undefined)
            reflectionMergePartial<BaseInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BaseInformation): BaseInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int64 createdDate */ 3:
                    message.createdDate = reader.int64().toBigInt();
                    break;
                case /* string createdBy */ 4:
                    message.createdBy = reader.string();
                    break;
                case /* optional int64 lastUpdatedDate */ 5:
                    message.lastUpdatedDate = reader.int64().toBigInt();
                    break;
                case /* optional string lastUpdatedBy */ 6:
                    message.lastUpdatedBy = reader.string();
                    break;
                case /* optional int64 deletedDate */ 7:
                    message.deletedDate = reader.int64().toBigInt();
                    break;
                case /* optional string deletedBy */ 8:
                    message.deletedBy = reader.string();
                    break;
                case /* int32 version */ 9:
                    message.version = reader.int32();
                    break;
                case /* bool obsolete */ 10:
                    message.obsolete = reader.bool();
                    break;
                case /* Uuid id */ 11:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* bool active */ 12:
                    message.active = reader.bool();
                    break;
                case /* optional int64 checkedOutDate */ 13:
                    message.checkedOutDate = reader.int64().toBigInt();
                    break;
                case /* optional string checkedOutBy */ 14:
                    message.checkedOutBy = reader.string();
                    break;
                case /* ObjectType objectType */ 15:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BaseInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int64 createdDate = 3; */
        if (message.createdDate !== 0n)
            writer.tag(3, WireType.Varint).int64(message.createdDate);
        /* string createdBy = 4; */
        if (message.createdBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdBy);
        /* optional int64 lastUpdatedDate = 5; */
        if (message.lastUpdatedDate !== undefined)
            writer.tag(5, WireType.Varint).int64(message.lastUpdatedDate);
        /* optional string lastUpdatedBy = 6; */
        if (message.lastUpdatedBy !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.lastUpdatedBy);
        /* optional int64 deletedDate = 7; */
        if (message.deletedDate !== undefined)
            writer.tag(7, WireType.Varint).int64(message.deletedDate);
        /* optional string deletedBy = 8; */
        if (message.deletedBy !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.deletedBy);
        /* int32 version = 9; */
        if (message.version !== 0)
            writer.tag(9, WireType.Varint).int32(message.version);
        /* bool obsolete = 10; */
        if (message.obsolete !== false)
            writer.tag(10, WireType.Varint).bool(message.obsolete);
        /* Uuid id = 11; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool active = 12; */
        if (message.active !== false)
            writer.tag(12, WireType.Varint).bool(message.active);
        /* optional int64 checkedOutDate = 13; */
        if (message.checkedOutDate !== undefined)
            writer.tag(13, WireType.Varint).int64(message.checkedOutDate);
        /* optional string checkedOutBy = 14; */
        if (message.checkedOutBy !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.checkedOutBy);
        /* ObjectType objectType = 15; */
        if (message.objectType !== 0)
            writer.tag(15, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BaseInformation
 */
export const BaseInformation = new BaseInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uuid$Type extends MessageType<Uuid> {
    constructor() {
        super("Uuid", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Uuid>): Uuid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<Uuid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uuid): Uuid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uuid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Uuid
 */
export const Uuid = new Uuid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Comment$Type extends MessageType<Comment> {
    constructor() {
        super("Comment", [
            { no: 1, name: "id", kind: "message", T: () => Uuid },
            { no: 2, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "createdDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "service", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Comment>): Comment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.comment = "";
        message.createdDate = 0n;
        message.createdBy = "";
        if (value !== undefined)
            reflectionMergePartial<Comment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Comment): Comment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Uuid id */ 1:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* string comment */ 2:
                    message.comment = reader.string();
                    break;
                case /* int64 createdDate */ 3:
                    message.createdDate = reader.int64().toBigInt();
                    break;
                case /* string createdBy */ 4:
                    message.createdBy = reader.string();
                    break;
                case /* optional string service */ 5:
                    message.service = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Comment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Uuid id = 1; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string comment = 2; */
        if (message.comment !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.comment);
        /* int64 createdDate = 3; */
        if (message.createdDate !== 0n)
            writer.tag(3, WireType.Varint).int64(message.createdDate);
        /* string createdBy = 4; */
        if (message.createdBy !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.createdBy);
        /* optional string service = 5; */
        if (message.service !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.service);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Comment
 */
export const Comment = new Comment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventHeader$Type extends MessageType<EventHeader> {
    constructor() {
        super("EventHeader", [
            { no: 1, name: "senderAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 5, name: "eventDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "senderApp", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "eventType", kind: "enum", T: () => ["EventType", EventType] }
        ]);
    }
    create(value?: PartialMessage<EventHeader>): EventHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderAddress = "";
        message.senderId = "";
        message.user = "";
        message.objectType = 0;
        message.eventDate = 0n;
        message.senderApp = "";
        message.eventType = 0;
        if (value !== undefined)
            reflectionMergePartial<EventHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventHeader): EventHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string senderAddress */ 1:
                    message.senderAddress = reader.string();
                    break;
                case /* string senderId */ 2:
                    message.senderId = reader.string();
                    break;
                case /* string user */ 3:
                    message.user = reader.string();
                    break;
                case /* ObjectType objectType */ 4:
                    message.objectType = reader.int32();
                    break;
                case /* int64 eventDate */ 5:
                    message.eventDate = reader.int64().toBigInt();
                    break;
                case /* string senderApp */ 6:
                    message.senderApp = reader.string();
                    break;
                case /* EventType eventType */ 7:
                    message.eventType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string senderAddress = 1; */
        if (message.senderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.senderAddress);
        /* string senderId = 2; */
        if (message.senderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderId);
        /* string user = 3; */
        if (message.user !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.user);
        /* ObjectType objectType = 4; */
        if (message.objectType !== 0)
            writer.tag(4, WireType.Varint).int32(message.objectType);
        /* int64 eventDate = 5; */
        if (message.eventDate !== 0n)
            writer.tag(5, WireType.Varint).int64(message.eventDate);
        /* string senderApp = 6; */
        if (message.senderApp !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.senderApp);
        /* EventType eventType = 7; */
        if (message.eventType !== 0)
            writer.tag(7, WireType.Varint).int32(message.eventType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EventHeader
 */
export const EventHeader = new EventHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestHeader$Type extends MessageType<RequestHeader> {
    constructor() {
        super("RequestHeader", [
            { no: 2, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "comment", kind: "message", T: () => Comment }
        ]);
    }
    create(value?: PartialMessage<RequestHeader>): RequestHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderId = "";
        message.user = "";
        if (value !== undefined)
            reflectionMergePartial<RequestHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestHeader): RequestHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string senderId */ 2:
                    message.senderId = reader.string();
                    break;
                case /* string user */ 3:
                    message.user = reader.string();
                    break;
                case /* optional Comment comment */ 4:
                    message.comment = Comment.internalBinaryRead(reader, reader.uint32(), options, message.comment);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string senderId = 2; */
        if (message.senderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderId);
        /* string user = 3; */
        if (message.user !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.user);
        /* optional Comment comment = 4; */
        if (message.comment)
            Comment.internalBinaryWrite(message.comment, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RequestHeader
 */
export const RequestHeader = new RequestHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplyHeader$Type extends MessageType<ReplyHeader> {
    constructor() {
        super("ReplyHeader", [
            { no: 2, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "successful", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "errorCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "timeStamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReplyHeader>): ReplyHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderId = "";
        message.errorMessage = "";
        message.successful = false;
        message.errorCode = 0;
        message.timeStamp = 0n;
        message.service = "";
        if (value !== undefined)
            reflectionMergePartial<ReplyHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplyHeader): ReplyHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string senderId */ 2:
                    message.senderId = reader.string();
                    break;
                case /* string errorMessage */ 3:
                    message.errorMessage = reader.string();
                    break;
                case /* bool successful */ 4:
                    message.successful = reader.bool();
                    break;
                case /* int32 errorCode */ 5:
                    message.errorCode = reader.int32();
                    break;
                case /* int64 timeStamp */ 6:
                    message.timeStamp = reader.int64().toBigInt();
                    break;
                case /* string service */ 7:
                    message.service = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplyHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string senderId = 2; */
        if (message.senderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderId);
        /* string errorMessage = 3; */
        if (message.errorMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.errorMessage);
        /* bool successful = 4; */
        if (message.successful !== false)
            writer.tag(4, WireType.Varint).bool(message.successful);
        /* int32 errorCode = 5; */
        if (message.errorCode !== 0)
            writer.tag(5, WireType.Varint).int32(message.errorCode);
        /* int64 timeStamp = 6; */
        if (message.timeStamp !== 0n)
            writer.tag(6, WireType.Varint).int64(message.timeStamp);
        /* string service = 7; */
        if (message.service !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.service);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReplyHeader
 */
export const ReplyHeader = new ReplyHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveReply$Type extends MessageType<SaveReply> {
    constructor() {
        super("SaveReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] }
        ]);
    }
    create(value?: PartialMessage<SaveReply>): SaveReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.objectType = 0;
        if (value !== undefined)
            reflectionMergePartial<SaveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveReply): SaveReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* ObjectType objectType */ 3:
                    message.objectType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* ObjectType objectType = 3; */
        if (message.objectType !== 0)
            writer.tag(3, WireType.Varint).int32(message.objectType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SaveReply
 */
export const SaveReply = new SaveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFilter$Type extends MessageType<RequestFilter> {
    constructor() {
        super("RequestFilter", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "connector", kind: "enum", T: () => ["FilterConnector", FilterConnector] },
            { no: 4, name: "dataType", kind: "enum", T: () => ["FilterDataType", FilterDataType] },
            { no: 5, name: "function", kind: "enum", T: () => ["FilterFunction", FilterFunction] }
        ]);
    }
    create(value?: PartialMessage<RequestFilter>): RequestFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        message.connector = 0;
        message.dataType = 0;
        message.function = 0;
        if (value !== undefined)
            reflectionMergePartial<RequestFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFilter): RequestFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* FilterConnector connector */ 3:
                    message.connector = reader.int32();
                    break;
                case /* FilterDataType dataType */ 4:
                    message.dataType = reader.int32();
                    break;
                case /* FilterFunction function */ 5:
                    message.function = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* FilterConnector connector = 3; */
        if (message.connector !== 0)
            writer.tag(3, WireType.Varint).int32(message.connector);
        /* FilterDataType dataType = 4; */
        if (message.dataType !== 0)
            writer.tag(4, WireType.Varint).int32(message.dataType);
        /* FilterFunction function = 5; */
        if (message.function !== 0)
            writer.tag(5, WireType.Varint).int32(message.function);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RequestFilter
 */
export const RequestFilter = new RequestFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestFilterDescriptor$Type extends MessageType<RequestFilterDescriptor> {
    constructor() {
        super("RequestFilterDescriptor", [
            { no: 1, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "dataType", kind: "enum", T: () => ["FilterDataType", FilterDataType] },
            { no: 4, name: "createdDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "lastUpdatedDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "lastUpdatedBy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "id", kind: "message", T: () => Uuid },
            { no: 9, name: "active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "obsolete", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RequestFilterDescriptor>): RequestFilterDescriptor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.key = "";
        message.dataType = 0;
        message.createdDate = 0n;
        message.createdBy = "";
        message.active = false;
        message.obsolete = false;
        if (value !== undefined)
            reflectionMergePartial<RequestFilterDescriptor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFilterDescriptor): RequestFilterDescriptor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ObjectType objectType */ 1:
                    message.objectType = reader.int32();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                case /* FilterDataType dataType */ 3:
                    message.dataType = reader.int32();
                    break;
                case /* int64 createdDate */ 4:
                    message.createdDate = reader.int64().toBigInt();
                    break;
                case /* string createdBy */ 5:
                    message.createdBy = reader.string();
                    break;
                case /* optional int64 lastUpdatedDate */ 6:
                    message.lastUpdatedDate = reader.int64().toBigInt();
                    break;
                case /* optional string lastUpdatedBy */ 7:
                    message.lastUpdatedBy = reader.string();
                    break;
                case /* Uuid id */ 8:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* bool active */ 9:
                    message.active = reader.bool();
                    break;
                case /* bool obsolete */ 10:
                    message.obsolete = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFilterDescriptor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ObjectType objectType = 1; */
        if (message.objectType !== 0)
            writer.tag(1, WireType.Varint).int32(message.objectType);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        /* FilterDataType dataType = 3; */
        if (message.dataType !== 0)
            writer.tag(3, WireType.Varint).int32(message.dataType);
        /* int64 createdDate = 4; */
        if (message.createdDate !== 0n)
            writer.tag(4, WireType.Varint).int64(message.createdDate);
        /* string createdBy = 5; */
        if (message.createdBy !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.createdBy);
        /* optional int64 lastUpdatedDate = 6; */
        if (message.lastUpdatedDate !== undefined)
            writer.tag(6, WireType.Varint).int64(message.lastUpdatedDate);
        /* optional string lastUpdatedBy = 7; */
        if (message.lastUpdatedBy !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.lastUpdatedBy);
        /* Uuid id = 8; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool active = 9; */
        if (message.active !== false)
            writer.tag(9, WireType.Varint).bool(message.active);
        /* bool obsolete = 10; */
        if (message.obsolete !== false)
            writer.tag(10, WireType.Varint).bool(message.obsolete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RequestFilterDescriptor
 */
export const RequestFilterDescriptor = new RequestFilterDescriptor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metric$Type extends MessageType<Metric> {
    constructor() {
        super("Metric", [
            { no: 1, name: "endPoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "successful", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "httpStatus", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "endTime", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "id", kind: "message", T: () => Uuid },
            { no: 7, name: "errorMessage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "errorCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Metric>): Metric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endPoint = "";
        message.successful = false;
        message.httpStatus = 0;
        message.startedTime = 0n;
        message.endTime = 0n;
        message.errorCode = 0;
        if (value !== undefined)
            reflectionMergePartial<Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metric): Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endPoint */ 1:
                    message.endPoint = reader.string();
                    break;
                case /* bool successful */ 2:
                    message.successful = reader.bool();
                    break;
                case /* int32 httpStatus */ 3:
                    message.httpStatus = reader.int32();
                    break;
                case /* int64 startedTime */ 4:
                    message.startedTime = reader.int64().toBigInt();
                    break;
                case /* int64 endTime */ 5:
                    message.endTime = reader.int64().toBigInt();
                    break;
                case /* Uuid id */ 6:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* optional string errorMessage */ 7:
                    message.errorMessage = reader.string();
                    break;
                case /* int32 errorCode */ 8:
                    message.errorCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endPoint = 1; */
        if (message.endPoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endPoint);
        /* bool successful = 2; */
        if (message.successful !== false)
            writer.tag(2, WireType.Varint).bool(message.successful);
        /* int32 httpStatus = 3; */
        if (message.httpStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.httpStatus);
        /* int64 startedTime = 4; */
        if (message.startedTime !== 0n)
            writer.tag(4, WireType.Varint).int64(message.startedTime);
        /* int64 endTime = 5; */
        if (message.endTime !== 0n)
            writer.tag(5, WireType.Varint).int64(message.endTime);
        /* Uuid id = 6; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional string errorMessage = 7; */
        if (message.errorMessage !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.errorMessage);
        /* int32 errorCode = 8; */
        if (message.errorCode !== 0)
            writer.tag(8, WireType.Varint).int32(message.errorCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Metric
 */
export const Metric = new Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricOverview$Type extends MessageType<MetricOverview> {
    constructor() {
        super("MetricOverview", [
            { no: 1, name: "endPoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "successfulCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "errorCount", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "averageDuration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "minDuration", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "maxDuration", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MetricOverview>): MetricOverview {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.endPoint = "";
        message.successfulCount = 0;
        message.errorCount = 0;
        message.averageDuration = 0;
        message.minDuration = 0;
        message.maxDuration = 0;
        if (value !== undefined)
            reflectionMergePartial<MetricOverview>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricOverview): MetricOverview {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endPoint */ 1:
                    message.endPoint = reader.string();
                    break;
                case /* int32 successfulCount */ 2:
                    message.successfulCount = reader.int32();
                    break;
                case /* int32 errorCount */ 3:
                    message.errorCount = reader.int32();
                    break;
                case /* float averageDuration */ 4:
                    message.averageDuration = reader.float();
                    break;
                case /* int32 minDuration */ 5:
                    message.minDuration = reader.int32();
                    break;
                case /* int32 maxDuration */ 6:
                    message.maxDuration = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricOverview, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endPoint = 1; */
        if (message.endPoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endPoint);
        /* int32 successfulCount = 2; */
        if (message.successfulCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.successfulCount);
        /* int32 errorCount = 3; */
        if (message.errorCount !== 0)
            writer.tag(3, WireType.Varint).int32(message.errorCount);
        /* float averageDuration = 4; */
        if (message.averageDuration !== 0)
            writer.tag(4, WireType.Bit32).float(message.averageDuration);
        /* int32 minDuration = 5; */
        if (message.minDuration !== 0)
            writer.tag(5, WireType.Varint).int32(message.minDuration);
        /* int32 maxDuration = 6; */
        if (message.maxDuration !== 0)
            writer.tag(6, WireType.Varint).int32(message.maxDuration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MetricOverview
 */
export const MetricOverview = new MetricOverview$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppGroup$Type extends MessageType<AppGroup> {
    constructor() {
        super("AppGroup", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "navigationItems", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppNavigationItem }
        ]);
    }
    create(value?: PartialMessage<AppGroup>): AppGroup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.navigationItems = [];
        if (value !== undefined)
            reflectionMergePartial<AppGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppGroup): AppGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string icon */ 2:
                    message.icon = reader.string();
                    break;
                case /* repeated AppNavigationItem navigationItems */ 3:
                    message.navigationItems.push(AppNavigationItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string icon = 2; */
        if (message.icon !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.icon);
        /* repeated AppNavigationItem navigationItems = 3; */
        for (let i = 0; i < message.navigationItems.length; i++)
            AppNavigationItem.internalBinaryWrite(message.navigationItems[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AppGroup
 */
export const AppGroup = new AppGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppNavigationItem$Type extends MessageType<AppNavigationItem> {
    constructor() {
        super("AppNavigationItem", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "icon", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "route", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "component", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppNavigationItem>): AppNavigationItem {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.route = "";
        message.component = "";
        if (value !== undefined)
            reflectionMergePartial<AppNavigationItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppNavigationItem): AppNavigationItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string icon */ 2:
                    message.icon = reader.string();
                    break;
                case /* string route */ 3:
                    message.route = reader.string();
                    break;
                case /* string component */ 4:
                    message.component = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppNavigationItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string icon = 2; */
        if (message.icon !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.icon);
        /* string route = 3; */
        if (message.route !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.route);
        /* string component = 4; */
        if (message.component !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.component);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AppNavigationItem
 */
export const AppNavigationItem = new AppNavigationItem$Type();
