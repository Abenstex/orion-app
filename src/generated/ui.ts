// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "ui.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AppGroup } from "./orion_common";
import { BaseInformation } from "./orion_common";
import { ReplyHeader } from "./orion_common";
import { RequestFilter } from "./orion_common";
import { RequestHeader } from "./orion_common";
import { EventHeader } from "./orion_common";
import { Uuid } from "./orion_common";
/**
 * @generated from protobuf message Translation
 */
export interface Translation {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string translation = 2
     */
    translation: string;
    /**
     * @generated from protobuf field: string language = 3
     */
    language: string;
    /**
     * @generated from protobuf field: string country = 4
     */
    country: string;
    /**
     * @generated from protobuf field: optional string lastChangedBy = 5
     */
    lastChangedBy?: string;
    /**
     * @generated from protobuf field: optional int64 lastChangedDate = 6
     */
    lastChangedDate?: bigint;
    /**
     * @generated from protobuf field: Uuid id = 7
     */
    id?: Uuid;
}
/**
 * @generated from protobuf message TranslationChangedEvent
 */
export interface TranslationChangedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: Translation translation = 2
     */
    translation?: Translation;
}
/**
 * @generated from protobuf message AddTranslationRequest
 */
export interface AddTranslationRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Translation translation = 2
     */
    translation?: Translation;
}
/**
 * @generated from protobuf message UpdateTranslationRequest
 */
export interface UpdateTranslationRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Translation translation = 2
     */
    translation?: Translation;
}
/**
 * @generated from protobuf message GetTranslationRequest
 */
export interface GetTranslationRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message DeleteTranslationRequest
 */
export interface DeleteTranslationRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string translationId = 2
     */
    translationId: string;
}
/**
 * @generated from protobuf message GetTranslationReply
 */
export interface GetTranslationReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated Translation translation = 2
     */
    translation: Translation[];
}
/**
 * @generated from protobuf message TranslLocale
 */
export interface TranslLocale {
    /**
     * @generated from protobuf field: string language = 3
     */
    language: string;
    /**
     * @generated from protobuf field: string country = 4
     */
    country: string;
}
/**
 * @generated from protobuf message AddTranslLocaleRequest
 */
export interface AddTranslLocaleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: TranslLocale locale = 2
     */
    locale?: TranslLocale;
}
/**
 * @generated from protobuf message GetAllTranslLocaleRequest
 */
export interface GetAllTranslLocaleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
}
/**
 * @generated from protobuf message GetAllTranslLocaleReply
 */
export interface GetAllTranslLocaleReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated TranslLocale locales = 2
     */
    locales: TranslLocale[];
}
/**
 * @generated from protobuf message DuplicateLocaleRequest
 */
export interface DuplicateLocaleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: TranslLocale locale = 2
     */
    locale?: TranslLocale;
    /**
     * @generated from protobuf field: string originalLanguage = 3
     */
    originalLanguage: string;
}
/**
 * @generated from protobuf message Dialog
 */
export interface Dialog {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: bool needsAdminRights = 2
     */
    needsAdminRights: boolean;
}
/**
 * @generated from protobuf message AddDialogRequest
 */
export interface AddDialogRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Dialog dialog = 2
     */
    dialog?: Dialog;
}
/**
 * @generated from protobuf message GetAllDialogsRequest
 */
export interface GetAllDialogsRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
}
/**
 * @generated from protobuf message UpdateDialogRequest
 */
export interface UpdateDialogRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Dialog dialog = 2
     */
    dialog?: Dialog;
}
/**
 * @generated from protobuf message DeleteDialogRequest
 */
export interface DeleteDialogRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string dialogId = 2
     */
    dialogId: string;
}
/**
 * @generated from protobuf message GetDialogsReply
 */
export interface GetDialogsReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated Dialog dialogs = 2
     */
    dialogs: Dialog[];
}
/**
 * @generated from protobuf message GetAppGroupsRequest
 */
export interface GetAppGroupsRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
}
/**
 * @generated from protobuf message GetAppGroupsReply
 */
export interface GetAppGroupsReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated AppGroup groups = 2
     */
    groups: AppGroup[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Translation$Type extends MessageType<Translation> {
    constructor() {
        super("Translation", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "translation", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "country", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "lastChangedBy", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "lastChangedDate", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "id", kind: "message", T: () => Uuid }
        ]);
    }
    create(value?: PartialMessage<Translation>): Translation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.translation = "";
        message.language = "";
        message.country = "";
        if (value !== undefined)
            reflectionMergePartial<Translation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Translation): Translation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string translation */ 2:
                    message.translation = reader.string();
                    break;
                case /* string language */ 3:
                    message.language = reader.string();
                    break;
                case /* string country */ 4:
                    message.country = reader.string();
                    break;
                case /* optional string lastChangedBy */ 5:
                    message.lastChangedBy = reader.string();
                    break;
                case /* optional int64 lastChangedDate */ 6:
                    message.lastChangedDate = reader.int64().toBigInt();
                    break;
                case /* Uuid id */ 7:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Translation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string translation = 2; */
        if (message.translation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.translation);
        /* string language = 3; */
        if (message.language !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.language);
        /* string country = 4; */
        if (message.country !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.country);
        /* optional string lastChangedBy = 5; */
        if (message.lastChangedBy !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.lastChangedBy);
        /* optional int64 lastChangedDate = 6; */
        if (message.lastChangedDate !== undefined)
            writer.tag(6, WireType.Varint).int64(message.lastChangedDate);
        /* Uuid id = 7; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Translation
 */
export const Translation = new Translation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslationChangedEvent$Type extends MessageType<TranslationChangedEvent> {
    constructor() {
        super("TranslationChangedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "translation", kind: "message", T: () => Translation }
        ]);
    }
    create(value?: PartialMessage<TranslationChangedEvent>): TranslationChangedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TranslationChangedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslationChangedEvent): TranslationChangedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Translation translation */ 2:
                    message.translation = Translation.internalBinaryRead(reader, reader.uint32(), options, message.translation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslationChangedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Translation translation = 2; */
        if (message.translation)
            Translation.internalBinaryWrite(message.translation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TranslationChangedEvent
 */
export const TranslationChangedEvent = new TranslationChangedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddTranslationRequest$Type extends MessageType<AddTranslationRequest> {
    constructor() {
        super("AddTranslationRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "translation", kind: "message", T: () => Translation }
        ]);
    }
    create(value?: PartialMessage<AddTranslationRequest>): AddTranslationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddTranslationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddTranslationRequest): AddTranslationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Translation translation */ 2:
                    message.translation = Translation.internalBinaryRead(reader, reader.uint32(), options, message.translation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddTranslationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Translation translation = 2; */
        if (message.translation)
            Translation.internalBinaryWrite(message.translation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddTranslationRequest
 */
export const AddTranslationRequest = new AddTranslationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTranslationRequest$Type extends MessageType<UpdateTranslationRequest> {
    constructor() {
        super("UpdateTranslationRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "translation", kind: "message", T: () => Translation }
        ]);
    }
    create(value?: PartialMessage<UpdateTranslationRequest>): UpdateTranslationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateTranslationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTranslationRequest): UpdateTranslationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Translation translation */ 2:
                    message.translation = Translation.internalBinaryRead(reader, reader.uint32(), options, message.translation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTranslationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Translation translation = 2; */
        if (message.translation)
            Translation.internalBinaryWrite(message.translation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateTranslationRequest
 */
export const UpdateTranslationRequest = new UpdateTranslationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTranslationRequest$Type extends MessageType<GetTranslationRequest> {
    constructor() {
        super("GetTranslationRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetTranslationRequest>): GetTranslationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetTranslationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTranslationRequest): GetTranslationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTranslationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTranslationRequest
 */
export const GetTranslationRequest = new GetTranslationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTranslationRequest$Type extends MessageType<DeleteTranslationRequest> {
    constructor() {
        super("DeleteTranslationRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "translationId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTranslationRequest>): DeleteTranslationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.translationId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteTranslationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTranslationRequest): DeleteTranslationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string translationId */ 2:
                    message.translationId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTranslationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string translationId = 2; */
        if (message.translationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.translationId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteTranslationRequest
 */
export const DeleteTranslationRequest = new DeleteTranslationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTranslationReply$Type extends MessageType<GetTranslationReply> {
    constructor() {
        super("GetTranslationReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "translation", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Translation }
        ]);
    }
    create(value?: PartialMessage<GetTranslationReply>): GetTranslationReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.translation = [];
        if (value !== undefined)
            reflectionMergePartial<GetTranslationReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTranslationReply): GetTranslationReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated Translation translation */ 2:
                    message.translation.push(Translation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTranslationReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Translation translation = 2; */
        for (let i = 0; i < message.translation.length; i++)
            Translation.internalBinaryWrite(message.translation[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetTranslationReply
 */
export const GetTranslationReply = new GetTranslationReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TranslLocale$Type extends MessageType<TranslLocale> {
    constructor() {
        super("TranslLocale", [
            { no: 3, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "country", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TranslLocale>): TranslLocale {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.language = "";
        message.country = "";
        if (value !== undefined)
            reflectionMergePartial<TranslLocale>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TranslLocale): TranslLocale {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 3:
                    message.language = reader.string();
                    break;
                case /* string country */ 4:
                    message.country = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TranslLocale, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 3; */
        if (message.language !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.language);
        /* string country = 4; */
        if (message.country !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.country);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TranslLocale
 */
export const TranslLocale = new TranslLocale$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddTranslLocaleRequest$Type extends MessageType<AddTranslLocaleRequest> {
    constructor() {
        super("AddTranslLocaleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "locale", kind: "message", T: () => TranslLocale }
        ]);
    }
    create(value?: PartialMessage<AddTranslLocaleRequest>): AddTranslLocaleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddTranslLocaleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddTranslLocaleRequest): AddTranslLocaleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* TranslLocale locale */ 2:
                    message.locale = TranslLocale.internalBinaryRead(reader, reader.uint32(), options, message.locale);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddTranslLocaleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* TranslLocale locale = 2; */
        if (message.locale)
            TranslLocale.internalBinaryWrite(message.locale, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddTranslLocaleRequest
 */
export const AddTranslLocaleRequest = new AddTranslLocaleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllTranslLocaleRequest$Type extends MessageType<GetAllTranslLocaleRequest> {
    constructor() {
        super("GetAllTranslLocaleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader }
        ]);
    }
    create(value?: PartialMessage<GetAllTranslLocaleRequest>): GetAllTranslLocaleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAllTranslLocaleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllTranslLocaleRequest): GetAllTranslLocaleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllTranslLocaleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllTranslLocaleRequest
 */
export const GetAllTranslLocaleRequest = new GetAllTranslLocaleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllTranslLocaleReply$Type extends MessageType<GetAllTranslLocaleReply> {
    constructor() {
        super("GetAllTranslLocaleReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "locales", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TranslLocale }
        ]);
    }
    create(value?: PartialMessage<GetAllTranslLocaleReply>): GetAllTranslLocaleReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locales = [];
        if (value !== undefined)
            reflectionMergePartial<GetAllTranslLocaleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllTranslLocaleReply): GetAllTranslLocaleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated TranslLocale locales */ 2:
                    message.locales.push(TranslLocale.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllTranslLocaleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated TranslLocale locales = 2; */
        for (let i = 0; i < message.locales.length; i++)
            TranslLocale.internalBinaryWrite(message.locales[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllTranslLocaleReply
 */
export const GetAllTranslLocaleReply = new GetAllTranslLocaleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DuplicateLocaleRequest$Type extends MessageType<DuplicateLocaleRequest> {
    constructor() {
        super("DuplicateLocaleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "locale", kind: "message", T: () => TranslLocale },
            { no: 3, name: "originalLanguage", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DuplicateLocaleRequest>): DuplicateLocaleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.originalLanguage = "";
        if (value !== undefined)
            reflectionMergePartial<DuplicateLocaleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DuplicateLocaleRequest): DuplicateLocaleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* TranslLocale locale */ 2:
                    message.locale = TranslLocale.internalBinaryRead(reader, reader.uint32(), options, message.locale);
                    break;
                case /* string originalLanguage */ 3:
                    message.originalLanguage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DuplicateLocaleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* TranslLocale locale = 2; */
        if (message.locale)
            TranslLocale.internalBinaryWrite(message.locale, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string originalLanguage = 3; */
        if (message.originalLanguage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.originalLanguage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DuplicateLocaleRequest
 */
export const DuplicateLocaleRequest = new DuplicateLocaleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Dialog$Type extends MessageType<Dialog> {
    constructor() {
        super("Dialog", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "needsAdminRights", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Dialog>): Dialog {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.needsAdminRights = false;
        if (value !== undefined)
            reflectionMergePartial<Dialog>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dialog): Dialog {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* bool needsAdminRights */ 2:
                    message.needsAdminRights = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Dialog, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool needsAdminRights = 2; */
        if (message.needsAdminRights !== false)
            writer.tag(2, WireType.Varint).bool(message.needsAdminRights);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Dialog
 */
export const Dialog = new Dialog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddDialogRequest$Type extends MessageType<AddDialogRequest> {
    constructor() {
        super("AddDialogRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "dialog", kind: "message", T: () => Dialog }
        ]);
    }
    create(value?: PartialMessage<AddDialogRequest>): AddDialogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddDialogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddDialogRequest): AddDialogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Dialog dialog */ 2:
                    message.dialog = Dialog.internalBinaryRead(reader, reader.uint32(), options, message.dialog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddDialogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Dialog dialog = 2; */
        if (message.dialog)
            Dialog.internalBinaryWrite(message.dialog, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddDialogRequest
 */
export const AddDialogRequest = new AddDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllDialogsRequest$Type extends MessageType<GetAllDialogsRequest> {
    constructor() {
        super("GetAllDialogsRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader }
        ]);
    }
    create(value?: PartialMessage<GetAllDialogsRequest>): GetAllDialogsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAllDialogsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllDialogsRequest): GetAllDialogsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllDialogsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAllDialogsRequest
 */
export const GetAllDialogsRequest = new GetAllDialogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateDialogRequest$Type extends MessageType<UpdateDialogRequest> {
    constructor() {
        super("UpdateDialogRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "dialog", kind: "message", T: () => Dialog }
        ]);
    }
    create(value?: PartialMessage<UpdateDialogRequest>): UpdateDialogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateDialogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateDialogRequest): UpdateDialogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Dialog dialog */ 2:
                    message.dialog = Dialog.internalBinaryRead(reader, reader.uint32(), options, message.dialog);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateDialogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Dialog dialog = 2; */
        if (message.dialog)
            Dialog.internalBinaryWrite(message.dialog, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateDialogRequest
 */
export const UpdateDialogRequest = new UpdateDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteDialogRequest$Type extends MessageType<DeleteDialogRequest> {
    constructor() {
        super("DeleteDialogRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "dialogId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteDialogRequest>): DeleteDialogRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dialogId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteDialogRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteDialogRequest): DeleteDialogRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string dialogId */ 2:
                    message.dialogId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteDialogRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string dialogId = 2; */
        if (message.dialogId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.dialogId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteDialogRequest
 */
export const DeleteDialogRequest = new DeleteDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDialogsReply$Type extends MessageType<GetDialogsReply> {
    constructor() {
        super("GetDialogsReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "dialogs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Dialog }
        ]);
    }
    create(value?: PartialMessage<GetDialogsReply>): GetDialogsReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dialogs = [];
        if (value !== undefined)
            reflectionMergePartial<GetDialogsReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDialogsReply): GetDialogsReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated Dialog dialogs */ 2:
                    message.dialogs.push(Dialog.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDialogsReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Dialog dialogs = 2; */
        for (let i = 0; i < message.dialogs.length; i++)
            Dialog.internalBinaryWrite(message.dialogs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDialogsReply
 */
export const GetDialogsReply = new GetDialogsReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppGroupsRequest$Type extends MessageType<GetAppGroupsRequest> {
    constructor() {
        super("GetAppGroupsRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader }
        ]);
    }
    create(value?: PartialMessage<GetAppGroupsRequest>): GetAppGroupsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetAppGroupsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAppGroupsRequest): GetAppGroupsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAppGroupsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAppGroupsRequest
 */
export const GetAppGroupsRequest = new GetAppGroupsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAppGroupsReply$Type extends MessageType<GetAppGroupsReply> {
    constructor() {
        super("GetAppGroupsReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "groups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppGroup }
        ]);
    }
    create(value?: PartialMessage<GetAppGroupsReply>): GetAppGroupsReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.groups = [];
        if (value !== undefined)
            reflectionMergePartial<GetAppGroupsReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAppGroupsReply): GetAppGroupsReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated AppGroup groups */ 2:
                    message.groups.push(AppGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAppGroupsReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated AppGroup groups = 2; */
        for (let i = 0; i < message.groups.length; i++)
            AppGroup.internalBinaryWrite(message.groups[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAppGroupsReply
 */
export const GetAppGroupsReply = new GetAppGroupsReply$Type();
