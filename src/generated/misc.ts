// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "misc.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Uuid } from "./orion_common";
import { RequestFilterDescriptor } from "./orion_common";
import { EventHeader } from "./orion_common";
import { RequestFilter } from "./orion_common";
import { BaseInformation } from "./orion_common";
import { Comment } from "./orion_common";
import { ReplyHeader } from "./orion_common";
import { ObjectType } from "./orion_common";
import { RequestHeader } from "./orion_common";
/**
 * @generated from protobuf message GetCommentsRequest
 */
export interface GetCommentsRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: ObjectType objectType = 2
     */
    objectType: ObjectType;
    /**
     * @generated from protobuf field: string objectId = 3
     */
    objectId: string;
}
/**
 * @generated from protobuf message GetCommentsReply
 */
export interface GetCommentsReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated Comment comments = 2
     */
    comments: Comment[];
}
/**
 * @generated from protobuf message ConfigParameter
 */
export interface ConfigParameter {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: string section = 2
     */
    section: string;
    /**
     * @generated from protobuf field: string group = 3
     */
    group: string;
    /**
     * @generated from protobuf field: string value = 4
     */
    value: string;
    /**
     * @generated from protobuf field: ParameterDataType dataType = 5
     */
    dataType: ParameterDataType;
}
/**
 * @generated from protobuf message AddConfigParameterRequest
 */
export interface AddConfigParameterRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: ConfigParameter parameter = 2
     */
    parameter?: ConfigParameter;
}
/**
 * @generated from protobuf message UpdateConfigParameterRequest
 */
export interface UpdateConfigParameterRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: ConfigParameter parameter = 2
     */
    parameter?: ConfigParameter;
}
/**
 * @generated from protobuf message DeleteConfigParameterRequest
 */
export interface DeleteConfigParameterRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string parameterId = 2
     */
    parameterId: string;
}
/**
 * @generated from protobuf message GetConfigParameterRequest
 */
export interface GetConfigParameterRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message GetConfigParameterReply
 */
export interface GetConfigParameterReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated ConfigParameter parameters = 2
     */
    parameters: ConfigParameter[];
}
/**
 * @generated from protobuf message ConfigParameterSavedEvent
 */
export interface ConfigParameterSavedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: ConfigParameter parameter = 2
     */
    parameter?: ConfigParameter;
}
/**
 * @generated from protobuf message ConfigParameterDeletedEvent
 */
export interface ConfigParameterDeletedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
}
/**
 * @generated from protobuf message AddRequestFilterDescriptorRequest
 */
export interface AddRequestFilterDescriptorRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: RequestFilterDescriptor descriptor = 2
     */
    descriptor?: RequestFilterDescriptor;
}
/**
 * @generated from protobuf message UpdateRequestFilterDescriptorRequest
 */
export interface UpdateRequestFilterDescriptorRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: RequestFilterDescriptor descriptor = 2
     */
    descriptor?: RequestFilterDescriptor;
}
/**
 * @generated from protobuf message DeleteRequestFilterDescriptorRequest
 */
export interface DeleteRequestFilterDescriptorRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: RequestFilterDescriptor descriptor = 2
     */
    descriptor?: RequestFilterDescriptor;
}
/**
 * @generated from protobuf message GetRequestFilterDescriptorRequest
 */
export interface GetRequestFilterDescriptorRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message GetRequestFilterDescriptorForObjectTypeRequest
 */
export interface GetRequestFilterDescriptorForObjectTypeRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: ObjectType type = 2
     */
    type: ObjectType;
}
/**
 * @generated from protobuf message GetRequestFilterDescriptorReply
 */
export interface GetRequestFilterDescriptorReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated RequestFilterDescriptor descriptors = 2
     */
    descriptors: RequestFilterDescriptor[];
}
/**
 * @generated from protobuf message UserMessage
 */
export interface UserMessage {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
    /**
     * @generated from protobuf field: string subject = 2
     */
    subject: string;
    /**
     * @generated from protobuf field: repeated string recipients = 3
     */
    recipients: string[];
    /**
     * @generated from protobuf field: int64 readDate = 4
     */
    readDate: bigint;
    /**
     * @generated from protobuf field: int64 sendDate = 5
     */
    sendDate: bigint;
    /**
     * @generated from protobuf field: string sender = 6
     */
    sender: string;
    /**
     * @generated from protobuf field: Uuid id = 7
     */
    id?: Uuid;
}
/**
 * @generated from protobuf message SendUserMessageRequest
 */
export interface SendUserMessageRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: UserMessage message = 2
     */
    message?: UserMessage;
}
/**
 * @generated from protobuf message GetUserMessageRequest
 */
export interface GetUserMessageRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string userId = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message MarkUserMessageAsReadRequest
 */
export interface MarkUserMessageAsReadRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string messageId = 2
     */
    messageId: string;
    /**
     * @generated from protobuf field: string userId = 3
     */
    userId: string;
}
/**
 * @generated from protobuf enum ParameterDataType
 */
export enum ParameterDataType {
    /**
     * @generated from protobuf enum value: PDT_UNKNOWN = 0;
     */
    PDT_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: PDT_STRING = 1;
     */
    PDT_STRING = 1,
    /**
     * @generated from protobuf enum value: PDT_INTEGER = 2;
     */
    PDT_INTEGER = 2,
    /**
     * @generated from protobuf enum value: PDT_DOUBLE = 3;
     */
    PDT_DOUBLE = 3,
    /**
     * @generated from protobuf enum value: PDT_COLOR = 4;
     */
    PDT_COLOR = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class GetCommentsRequest$Type extends MessageType<GetCommentsRequest> {
    constructor() {
        super("GetCommentsRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 3, name: "objectId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetCommentsRequest>): GetCommentsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectType = 0;
        message.objectId = "";
        if (value !== undefined)
            reflectionMergePartial<GetCommentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCommentsRequest): GetCommentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* ObjectType objectType */ 2:
                    message.objectType = reader.int32();
                    break;
                case /* string objectId */ 3:
                    message.objectId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCommentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ObjectType objectType = 2; */
        if (message.objectType !== 0)
            writer.tag(2, WireType.Varint).int32(message.objectType);
        /* string objectId = 3; */
        if (message.objectId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.objectId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCommentsRequest
 */
export const GetCommentsRequest = new GetCommentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCommentsReply$Type extends MessageType<GetCommentsReply> {
    constructor() {
        super("GetCommentsReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "comments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Comment }
        ]);
    }
    create(value?: PartialMessage<GetCommentsReply>): GetCommentsReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.comments = [];
        if (value !== undefined)
            reflectionMergePartial<GetCommentsReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCommentsReply): GetCommentsReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated Comment comments */ 2:
                    message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCommentsReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Comment comments = 2; */
        for (let i = 0; i < message.comments.length; i++)
            Comment.internalBinaryWrite(message.comments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCommentsReply
 */
export const GetCommentsReply = new GetCommentsReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigParameter$Type extends MessageType<ConfigParameter> {
    constructor() {
        super("ConfigParameter", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "section", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dataType", kind: "enum", T: () => ["ParameterDataType", ParameterDataType] }
        ]);
    }
    create(value?: PartialMessage<ConfigParameter>): ConfigParameter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.section = "";
        message.group = "";
        message.value = "";
        message.dataType = 0;
        if (value !== undefined)
            reflectionMergePartial<ConfigParameter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigParameter): ConfigParameter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* string section */ 2:
                    message.section = reader.string();
                    break;
                case /* string group */ 3:
                    message.group = reader.string();
                    break;
                case /* string value */ 4:
                    message.value = reader.string();
                    break;
                case /* ParameterDataType dataType */ 5:
                    message.dataType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigParameter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string section = 2; */
        if (message.section !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.section);
        /* string group = 3; */
        if (message.group !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.group);
        /* string value = 4; */
        if (message.value !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.value);
        /* ParameterDataType dataType = 5; */
        if (message.dataType !== 0)
            writer.tag(5, WireType.Varint).int32(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConfigParameter
 */
export const ConfigParameter = new ConfigParameter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddConfigParameterRequest$Type extends MessageType<AddConfigParameterRequest> {
    constructor() {
        super("AddConfigParameterRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "parameter", kind: "message", T: () => ConfigParameter }
        ]);
    }
    create(value?: PartialMessage<AddConfigParameterRequest>): AddConfigParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddConfigParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddConfigParameterRequest): AddConfigParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* ConfigParameter parameter */ 2:
                    message.parameter = ConfigParameter.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddConfigParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ConfigParameter parameter = 2; */
        if (message.parameter)
            ConfigParameter.internalBinaryWrite(message.parameter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddConfigParameterRequest
 */
export const AddConfigParameterRequest = new AddConfigParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfigParameterRequest$Type extends MessageType<UpdateConfigParameterRequest> {
    constructor() {
        super("UpdateConfigParameterRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "parameter", kind: "message", T: () => ConfigParameter }
        ]);
    }
    create(value?: PartialMessage<UpdateConfigParameterRequest>): UpdateConfigParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateConfigParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfigParameterRequest): UpdateConfigParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* ConfigParameter parameter */ 2:
                    message.parameter = ConfigParameter.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfigParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ConfigParameter parameter = 2; */
        if (message.parameter)
            ConfigParameter.internalBinaryWrite(message.parameter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateConfigParameterRequest
 */
export const UpdateConfigParameterRequest = new UpdateConfigParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteConfigParameterRequest$Type extends MessageType<DeleteConfigParameterRequest> {
    constructor() {
        super("DeleteConfigParameterRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "parameterId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteConfigParameterRequest>): DeleteConfigParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameterId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteConfigParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteConfigParameterRequest): DeleteConfigParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string parameterId */ 2:
                    message.parameterId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteConfigParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string parameterId = 2; */
        if (message.parameterId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parameterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteConfigParameterRequest
 */
export const DeleteConfigParameterRequest = new DeleteConfigParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigParameterRequest$Type extends MessageType<GetConfigParameterRequest> {
    constructor() {
        super("GetConfigParameterRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetConfigParameterRequest>): GetConfigParameterRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetConfigParameterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigParameterRequest): GetConfigParameterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConfigParameterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetConfigParameterRequest
 */
export const GetConfigParameterRequest = new GetConfigParameterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConfigParameterReply$Type extends MessageType<GetConfigParameterReply> {
    constructor() {
        super("GetConfigParameterReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "parameters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ConfigParameter }
        ]);
    }
    create(value?: PartialMessage<GetConfigParameterReply>): GetConfigParameterReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parameters = [];
        if (value !== undefined)
            reflectionMergePartial<GetConfigParameterReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConfigParameterReply): GetConfigParameterReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated ConfigParameter parameters */ 2:
                    message.parameters.push(ConfigParameter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConfigParameterReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated ConfigParameter parameters = 2; */
        for (let i = 0; i < message.parameters.length; i++)
            ConfigParameter.internalBinaryWrite(message.parameters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetConfigParameterReply
 */
export const GetConfigParameterReply = new GetConfigParameterReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigParameterSavedEvent$Type extends MessageType<ConfigParameterSavedEvent> {
    constructor() {
        super("ConfigParameterSavedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "parameter", kind: "message", T: () => ConfigParameter }
        ]);
    }
    create(value?: PartialMessage<ConfigParameterSavedEvent>): ConfigParameterSavedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConfigParameterSavedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigParameterSavedEvent): ConfigParameterSavedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* ConfigParameter parameter */ 2:
                    message.parameter = ConfigParameter.internalBinaryRead(reader, reader.uint32(), options, message.parameter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigParameterSavedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ConfigParameter parameter = 2; */
        if (message.parameter)
            ConfigParameter.internalBinaryWrite(message.parameter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConfigParameterSavedEvent
 */
export const ConfigParameterSavedEvent = new ConfigParameterSavedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigParameterDeletedEvent$Type extends MessageType<ConfigParameterDeletedEvent> {
    constructor() {
        super("ConfigParameterDeletedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigParameterDeletedEvent>): ConfigParameterDeletedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<ConfigParameterDeletedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigParameterDeletedEvent): ConfigParameterDeletedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigParameterDeletedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConfigParameterDeletedEvent
 */
export const ConfigParameterDeletedEvent = new ConfigParameterDeletedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddRequestFilterDescriptorRequest$Type extends MessageType<AddRequestFilterDescriptorRequest> {
    constructor() {
        super("AddRequestFilterDescriptorRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "descriptor", kind: "message", T: () => RequestFilterDescriptor }
        ]);
    }
    create(value?: PartialMessage<AddRequestFilterDescriptorRequest>): AddRequestFilterDescriptorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddRequestFilterDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddRequestFilterDescriptorRequest): AddRequestFilterDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* RequestFilterDescriptor descriptor */ 2:
                    message.descriptor = RequestFilterDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.descriptor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddRequestFilterDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* RequestFilterDescriptor descriptor = 2; */
        if (message.descriptor)
            RequestFilterDescriptor.internalBinaryWrite(message.descriptor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddRequestFilterDescriptorRequest
 */
export const AddRequestFilterDescriptorRequest = new AddRequestFilterDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRequestFilterDescriptorRequest$Type extends MessageType<UpdateRequestFilterDescriptorRequest> {
    constructor() {
        super("UpdateRequestFilterDescriptorRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "descriptor", kind: "message", T: () => RequestFilterDescriptor }
        ]);
    }
    create(value?: PartialMessage<UpdateRequestFilterDescriptorRequest>): UpdateRequestFilterDescriptorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateRequestFilterDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRequestFilterDescriptorRequest): UpdateRequestFilterDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* RequestFilterDescriptor descriptor */ 2:
                    message.descriptor = RequestFilterDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.descriptor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRequestFilterDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* RequestFilterDescriptor descriptor = 2; */
        if (message.descriptor)
            RequestFilterDescriptor.internalBinaryWrite(message.descriptor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateRequestFilterDescriptorRequest
 */
export const UpdateRequestFilterDescriptorRequest = new UpdateRequestFilterDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRequestFilterDescriptorRequest$Type extends MessageType<DeleteRequestFilterDescriptorRequest> {
    constructor() {
        super("DeleteRequestFilterDescriptorRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "descriptor", kind: "message", T: () => RequestFilterDescriptor }
        ]);
    }
    create(value?: PartialMessage<DeleteRequestFilterDescriptorRequest>): DeleteRequestFilterDescriptorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DeleteRequestFilterDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRequestFilterDescriptorRequest): DeleteRequestFilterDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* RequestFilterDescriptor descriptor */ 2:
                    message.descriptor = RequestFilterDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.descriptor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRequestFilterDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* RequestFilterDescriptor descriptor = 2; */
        if (message.descriptor)
            RequestFilterDescriptor.internalBinaryWrite(message.descriptor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteRequestFilterDescriptorRequest
 */
export const DeleteRequestFilterDescriptorRequest = new DeleteRequestFilterDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequestFilterDescriptorRequest$Type extends MessageType<GetRequestFilterDescriptorRequest> {
    constructor() {
        super("GetRequestFilterDescriptorRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetRequestFilterDescriptorRequest>): GetRequestFilterDescriptorRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetRequestFilterDescriptorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequestFilterDescriptorRequest): GetRequestFilterDescriptorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequestFilterDescriptorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRequestFilterDescriptorRequest
 */
export const GetRequestFilterDescriptorRequest = new GetRequestFilterDescriptorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequestFilterDescriptorForObjectTypeRequest$Type extends MessageType<GetRequestFilterDescriptorForObjectTypeRequest> {
    constructor() {
        super("GetRequestFilterDescriptorForObjectTypeRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "type", kind: "enum", T: () => ["ObjectType", ObjectType] }
        ]);
    }
    create(value?: PartialMessage<GetRequestFilterDescriptorForObjectTypeRequest>): GetRequestFilterDescriptorForObjectTypeRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<GetRequestFilterDescriptorForObjectTypeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequestFilterDescriptorForObjectTypeRequest): GetRequestFilterDescriptorForObjectTypeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* ObjectType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequestFilterDescriptorForObjectTypeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ObjectType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRequestFilterDescriptorForObjectTypeRequest
 */
export const GetRequestFilterDescriptorForObjectTypeRequest = new GetRequestFilterDescriptorForObjectTypeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRequestFilterDescriptorReply$Type extends MessageType<GetRequestFilterDescriptorReply> {
    constructor() {
        super("GetRequestFilterDescriptorReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "descriptors", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilterDescriptor }
        ]);
    }
    create(value?: PartialMessage<GetRequestFilterDescriptorReply>): GetRequestFilterDescriptorReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.descriptors = [];
        if (value !== undefined)
            reflectionMergePartial<GetRequestFilterDescriptorReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRequestFilterDescriptorReply): GetRequestFilterDescriptorReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilterDescriptor descriptors */ 2:
                    message.descriptors.push(RequestFilterDescriptor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRequestFilterDescriptorReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilterDescriptor descriptors = 2; */
        for (let i = 0; i < message.descriptors.length; i++)
            RequestFilterDescriptor.internalBinaryWrite(message.descriptors[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRequestFilterDescriptorReply
 */
export const GetRequestFilterDescriptorReply = new GetRequestFilterDescriptorReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserMessage$Type extends MessageType<UserMessage> {
    constructor() {
        super("UserMessage", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "subject", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "recipients", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "readDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "sendDate", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "id", kind: "message", T: () => Uuid }
        ]);
    }
    create(value?: PartialMessage<UserMessage>): UserMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        message.subject = "";
        message.recipients = [];
        message.readDate = 0n;
        message.sendDate = 0n;
        message.sender = "";
        if (value !== undefined)
            reflectionMergePartial<UserMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserMessage): UserMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* string subject */ 2:
                    message.subject = reader.string();
                    break;
                case /* repeated string recipients */ 3:
                    message.recipients.push(reader.string());
                    break;
                case /* int64 readDate */ 4:
                    message.readDate = reader.int64().toBigInt();
                    break;
                case /* int64 sendDate */ 5:
                    message.sendDate = reader.int64().toBigInt();
                    break;
                case /* string sender */ 6:
                    message.sender = reader.string();
                    break;
                case /* Uuid id */ 7:
                    message.id = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* string subject = 2; */
        if (message.subject !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.subject);
        /* repeated string recipients = 3; */
        for (let i = 0; i < message.recipients.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.recipients[i]);
        /* int64 readDate = 4; */
        if (message.readDate !== 0n)
            writer.tag(4, WireType.Varint).int64(message.readDate);
        /* int64 sendDate = 5; */
        if (message.sendDate !== 0n)
            writer.tag(5, WireType.Varint).int64(message.sendDate);
        /* string sender = 6; */
        if (message.sender !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sender);
        /* Uuid id = 7; */
        if (message.id)
            Uuid.internalBinaryWrite(message.id, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserMessage
 */
export const UserMessage = new UserMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendUserMessageRequest$Type extends MessageType<SendUserMessageRequest> {
    constructor() {
        super("SendUserMessageRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "message", kind: "message", T: () => UserMessage }
        ]);
    }
    create(value?: PartialMessage<SendUserMessageRequest>): SendUserMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SendUserMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendUserMessageRequest): SendUserMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* UserMessage message */ 2:
                    message.message = UserMessage.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendUserMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* UserMessage message = 2; */
        if (message.message)
            UserMessage.internalBinaryWrite(message.message, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SendUserMessageRequest
 */
export const SendUserMessageRequest = new SendUserMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserMessageRequest$Type extends MessageType<GetUserMessageRequest> {
    constructor() {
        super("GetUserMessageRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetUserMessageRequest>): GetUserMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUserMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserMessageRequest): GetUserMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userId = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserMessageRequest
 */
export const GetUserMessageRequest = new GetUserMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarkUserMessageAsReadRequest$Type extends MessageType<MarkUserMessageAsReadRequest> {
    constructor() {
        super("MarkUserMessageAsReadRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "messageId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarkUserMessageAsReadRequest>): MarkUserMessageAsReadRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageId = "";
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<MarkUserMessageAsReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarkUserMessageAsReadRequest): MarkUserMessageAsReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string messageId */ 2:
                    message.messageId = reader.string();
                    break;
                case /* string userId */ 3:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarkUserMessageAsReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string messageId = 2; */
        if (message.messageId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.messageId);
        /* string userId = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MarkUserMessageAsReadRequest
 */
export const MarkUserMessageAsReadRequest = new MarkUserMessageAsReadRequest$Type();
