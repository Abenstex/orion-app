// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "user.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ReplyHeader } from "./orion_common";
import { RequestFilter } from "./orion_common";
import { RequestHeader } from "./orion_common";
import { EventHeader } from "./orion_common";
import { AppGroup } from "./orion_common";
import { BaseInformation } from "./orion_common";
/**
 * @generated from protobuf message User
 */
export interface User {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
    /**
     * @generated from protobuf field: bool isAdmin = 3
     */
    isAdmin: boolean;
    /**
     * @generated from protobuf field: string email = 4
     */
    email: string;
    /**
     * @generated from protobuf field: optional int64 birthday = 5
     */
    birthday?: bigint;
    /**
     * @generated from protobuf field: string first_name = 6
     */
    firstName: string;
    /**
     * @generated from protobuf field: string last_name = 7
     */
    lastName: string;
    /**
     * @generated from protobuf field: repeated AppGroup appGroups = 8
     */
    appGroups: AppGroup[];
}
/**
 * @generated from protobuf message UserSavedEvent
 */
export interface UserSavedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: User user = 2
     */
    user?: User;
}
/**
 * @generated from protobuf message AddUserRequest
 */
export interface AddUserRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: User user = 2
     */
    user?: User;
}
/**
 * @generated from protobuf message LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string userName = 2
     */
    userName: string;
    /**
     * @generated from protobuf field: string password = 3
     */
    password: string;
}
/**
 * @generated from protobuf message LogoutRequest
 */
export interface LogoutRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string userName = 2
     */
    userName: string;
    /**
     * @generated from protobuf field: string senderId = 3
     */
    senderId: string;
}
/**
 * @generated from protobuf message UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: User user = 2
     */
    user?: User;
}
/**
 * @generated from protobuf message ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string userId = 2
     */
    userId: string;
    /**
     * @generated from protobuf field: string password = 3
     */
    password: string;
}
/**
 * @generated from protobuf message GetUserRequest
 */
export interface GetUserRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message DeleteUserRequest
 */
export interface DeleteUserRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string userId = 2
     */
    userId: string;
}
/**
 * @generated from protobuf message GetUserReply
 */
export interface GetUserReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated User users = 2
     */
    users: User[];
}
/**
 * @generated from protobuf message LoginReply
 */
export interface LoginReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: User user = 2
     */
    user?: User;
    /**
     * @generated from protobuf field: string token = 3
     */
    token: string;
    /**
     * @generated from protobuf field: int64 tokenExpires = 4
     */
    tokenExpires: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("User", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "isAdmin", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "email", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "birthday", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "first_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "last_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "appGroups", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AppGroup }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.password = "";
        message.isAdmin = false;
        message.email = "";
        message.firstName = "";
        message.lastName = "";
        message.appGroups = [];
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                case /* bool isAdmin */ 3:
                    message.isAdmin = reader.bool();
                    break;
                case /* string email */ 4:
                    message.email = reader.string();
                    break;
                case /* optional int64 birthday */ 5:
                    message.birthday = reader.int64().toBigInt();
                    break;
                case /* string first_name */ 6:
                    message.firstName = reader.string();
                    break;
                case /* string last_name */ 7:
                    message.lastName = reader.string();
                    break;
                case /* repeated AppGroup appGroups */ 8:
                    message.appGroups.push(AppGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        /* bool isAdmin = 3; */
        if (message.isAdmin !== false)
            writer.tag(3, WireType.Varint).bool(message.isAdmin);
        /* string email = 4; */
        if (message.email !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.email);
        /* optional int64 birthday = 5; */
        if (message.birthday !== undefined)
            writer.tag(5, WireType.Varint).int64(message.birthday);
        /* string first_name = 6; */
        if (message.firstName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.firstName);
        /* string last_name = 7; */
        if (message.lastName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.lastName);
        /* repeated AppGroup appGroups = 8; */
        for (let i = 0; i < message.appGroups.length; i++)
            AppGroup.internalBinaryWrite(message.appGroups[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserSavedEvent$Type extends MessageType<UserSavedEvent> {
    constructor() {
        super("UserSavedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<UserSavedEvent>): UserSavedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UserSavedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserSavedEvent): UserSavedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserSavedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UserSavedEvent
 */
export const UserSavedEvent = new UserSavedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddUserRequest$Type extends MessageType<AddUserRequest> {
    constructor() {
        super("AddUserRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<AddUserRequest>): AddUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddUserRequest): AddUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddUserRequest
 */
export const AddUserRequest = new AddUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("LoginRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "userName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userName = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string userName */ 2:
                    message.userName = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userName = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogoutRequest$Type extends MessageType<LogoutRequest> {
    constructor() {
        super("LogoutRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "userName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LogoutRequest>): LogoutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userName = "";
        message.senderId = "";
        if (value !== undefined)
            reflectionMergePartial<LogoutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LogoutRequest): LogoutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string userName */ 2:
                    message.userName = reader.string();
                    break;
                case /* string senderId */ 3:
                    message.senderId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LogoutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userName = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* string senderId = 3; */
        if (message.senderId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.senderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LogoutRequest
 */
export const LogoutRequest = new LogoutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateUserRequest$Type extends MessageType<UpdateUserRequest> {
    constructor() {
        super("UpdateUserRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "user", kind: "message", T: () => User }
        ]);
    }
    create(value?: PartialMessage<UpdateUserRequest>): UpdateUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateUserRequest): UpdateUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateUserRequest
 */
export const UpdateUserRequest = new UpdateUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangePasswordRequest$Type extends MessageType<ChangePasswordRequest> {
    constructor() {
        super("ChangePasswordRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChangePasswordRequest>): ChangePasswordRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<ChangePasswordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangePasswordRequest): ChangePasswordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string userId */ 2:
                    message.userId = reader.string();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangePasswordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userId = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangePasswordRequest
 */
export const ChangePasswordRequest = new ChangePasswordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserRequest$Type extends MessageType<GetUserRequest> {
    constructor() {
        super("GetUserRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetUserRequest>): GetUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserRequest): GetUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserRequest
 */
export const GetUserRequest = new GetUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteUserRequest$Type extends MessageType<DeleteUserRequest> {
    constructor() {
        super("DeleteUserRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteUserRequest>): DeleteUserRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteUserRequest): DeleteUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string userId */ 2:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string userId = 2; */
        if (message.userId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteUserRequest
 */
export const DeleteUserRequest = new DeleteUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUserReply$Type extends MessageType<GetUserReply> {
    constructor() {
        super("GetUserReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "users", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => User }
        ]);
    }
    create(value?: PartialMessage<GetUserReply>): GetUserReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.users = [];
        if (value !== undefined)
            reflectionMergePartial<GetUserReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUserReply): GetUserReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated User users */ 2:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUserReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated User users = 2; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetUserReply
 */
export const GetUserReply = new GetUserReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginReply$Type extends MessageType<LoginReply> {
    constructor() {
        super("LoginReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "user", kind: "message", T: () => User },
            { no: 3, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "tokenExpires", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LoginReply>): LoginReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.tokenExpires = 0n;
        if (value !== undefined)
            reflectionMergePartial<LoginReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginReply): LoginReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* User user */ 2:
                    message.user = User.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* string token */ 3:
                    message.token = reader.string();
                    break;
                case /* int64 tokenExpires */ 4:
                    message.tokenExpires = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* User user = 2; */
        if (message.user)
            User.internalBinaryWrite(message.user, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string token = 3; */
        if (message.token !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.token);
        /* int64 tokenExpires = 4; */
        if (message.tokenExpires !== 0n)
            writer.tag(4, WireType.Varint).int64(message.tokenExpires);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoginReply
 */
export const LoginReply = new LoginReply$Type();
