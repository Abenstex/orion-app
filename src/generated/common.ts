// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "common.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message ObjectId
 */
export interface ObjectId {
    /**
     * @generated from protobuf field: string value = 1
     */
    value: string;
}
/**
 * @generated from protobuf message Term
 */
export interface Term {
    /**
     * @generated from protobuf field: string Term = 1
     */
    term: string;
    /**
     * @generated from protobuf field: int32 Frequency = 2
     */
    frequency: number;
    /**
     * @generated from protobuf field: double ZipfValue = 3
     */
    zipfValue: number;
    /**
     * @generated from protobuf field: bool Stemmed = 4
     */
    stemmed: boolean;
}
// message RequestReply {// structs.ObjectId id = 1 [(tags) = "bson:\"_id,omitempty\"" ];  // @gotags: bson:"_id,omitempty";// string request = 2;// string reply = 3;// string serviceName = 4;// string address = 5;// int32 port = 6;// string version = 7;// string methodName = 8;// int32 methodVersion = 9;// string fullMethodName = 10;// string appName = 11;// bool successful = 12;// }

/**
 * @generated from protobuf message SqlRequestReply
 */
export interface SqlRequestReply {
    /**
     * @generated from protobuf field: Uuid ID = 1
     */
    iD?: Uuid; // @gotags: bson:"_id,omitempty" gorm:"primaryKey";     /**
     * @generated from protobuf field: string request = 2
     */
    request: string;
    /**
     * @generated from protobuf field: string reply = 3
     */
    reply: string;
    /**
     * @generated from protobuf field: string serviceName = 4
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string address = 5
     */
    address: string;
    /**
     * @generated from protobuf field: int32 port = 6
     */
    port: number;
    /**
     * @generated from protobuf field: string version = 7
     */
    version: string;
    /**
     * @generated from protobuf field: string methodName = 8
     */
    methodName: string;
    /**
     * @generated from protobuf field: int32 methodVersion = 9
     */
    methodVersion: number;
    /**
     * @generated from protobuf field: string fullMethodName = 10
     */
    fullMethodName: string;
    /**
     * @generated from protobuf field: string appName = 11
     */
    appName: string;
    /**
     * @generated from protobuf field: bool successful = 12
     */
    successful: boolean;
    /**
     * @generated from protobuf field: int64 createdAt = 13
     */
    createdAt: string; // @gotags: gorm:"autoCreateTime:milli"}
/**
 * @generated from protobuf message Heartbeat
 */
export interface Heartbeat {
    /**
     * @generated from protobuf field: int64 currentTime = 1
     */
    currentTime: string;
    /**
     * @generated from protobuf field: int64 startedTime = 2
     */
    startedTime: string;
    /**
     * @generated from protobuf field: string appName = 3
     */
    appName: string;
    /**
     * @generated from protobuf field: string appVersion = 4
     */
    appVersion: string;
    /**
     * @generated from protobuf field: string hostAddress = 5
     */
    hostAddress: string;
    /**
     * @generated from protobuf field: int32 port = 6
     */
    port: number;
    /**
     * @generated from protobuf field: int32 numGoRoutines = 7
     */
    numGoRoutines: number;
    /**
     * @generated from protobuf field: int32 numCpu = 8
     */
    numCpu: number;
    /**
     * @generated from protobuf field: string goOs = 9
     */
    goOs: string;
    /**
     * @generated from protobuf field: string goArch = 10
     */
    goArch: string;
    /**
     * @generated from protobuf field: string goVersion = 11
     */
    goVersion: string;
    /**
     * @generated from protobuf field: uint64 allocBytes = 12
     */
    allocBytes: string;
    /**
     * @generated from protobuf field: uint64 totalAllocBytes = 13
     */
    totalAllocBytes: string;
    /**
     * @generated from protobuf field: uint64 sysBytes = 14
     */
    sysBytes: string;
    /**
     * @generated from protobuf field: uint64 lookups = 15
     */
    lookups: string;
}
/**
 * @generated from protobuf message Uuid
 */
export interface Uuid {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
}
/**
 * @generated from protobuf message MethodMetric
 */
export interface MethodMetric {
    /**
     * @generated from protobuf field: string appName = 1
     */
    appName: string; // @gotags: bson:"appName"    /**
     * @generated from protobuf field: string appVersion = 2
     */
    appVersion: string; // @gotags: bson:"appVersion"    /**
     * @generated from protobuf field: int64 startedTime = 3
     */
    startedTime: string; // @gotags: bson:"startedTime"    /**
     * @generated from protobuf field: int64 endTime = 4
     */
    endTime: string; // @gotags: bson:"endTime"    /**
     * @generated from protobuf field: int64 numberOfCalls = 5
     */
    numberOfCalls: string; // @gotags: bson:"numberOfCalls"    /**
     * @generated from protobuf field: float avgDuration = 6
     */
    avgDuration: number; // @gotags: bson:"avgDuration"    /**
     * @generated from protobuf field: int64 sumDuration = 7
     */
    sumDuration: string; // @gotags: bson:"sumDuration"    /**
     * @generated from protobuf field: int64 minDuration = 8
     */
    minDuration: string; // @gotags: bson:"minDuration"    /**
     * @generated from protobuf field: int64 maxDuration = 9
     */
    maxDuration: string; // @gotags: bson:"maxDuration"    /**
     * @generated from protobuf field: int64 lastUpdate = 10
     */
    lastUpdate: string; // @gotags: bson:"lastUpdate"    /**
     * @generated from protobuf field: string methodName = 11
     */
    methodName: string; // @gotags: bson:"methodName"    /**
     * @generated from protobuf field: int32 methodVersion = 12
     */
    methodVersion: number; // @gotags: bson:"methodVersion"    /**
     * @generated from protobuf field: int32 successfulCalls = 13
     */
    successfulCalls: number; // @gotags: bson:"successfulCalls"    /**
     * @generated from protobuf field: ObjectId id = 14
     */
    id?: ObjectId;
}
/**
 * @generated from protobuf message SqlMethodMetric
 */
export interface SqlMethodMetric {
    /**
     * @generated from protobuf field: string appName = 1
     */
    appName: string; // @gotags: bson:"appName" gorm:"primaryKey"    /**
     * @generated from protobuf field: string appVersion = 2
     */
    appVersion: string; // @gotags: bson:"appVersion"    /**
     * @generated from protobuf field: int64 startedTime = 3
     */
    startedTime: string; // @gotags: bson:"startedTime"    /**
     * @generated from protobuf field: int64 endTime = 4
     */
    endTime: string; // @gotags: bson:"endTime"    /**
     * @generated from protobuf field: int64 numberOfCalls = 5
     */
    numberOfCalls: string; // @gotags: bson:"numberOfCalls"    /**
     * @generated from protobuf field: float avgDuration = 6
     */
    avgDuration: number; // @gotags: bson:"avgDuration"    /**
     * @generated from protobuf field: int64 sumDuration = 7
     */
    sumDuration: string; // @gotags: bson:"sumDuration"    /**
     * @generated from protobuf field: int64 minDuration = 8
     */
    minDuration: string; // @gotags: bson:"minDuration"    /**
     * @generated from protobuf field: int64 maxDuration = 9
     */
    maxDuration: string; // @gotags: bson:"maxDuration"    /**
     * @generated from protobuf field: int64 lastUpdate = 10
     */
    lastUpdate: string; // @gotags: bson:"lastUpdate"    /**
     * @generated from protobuf field: string methodName = 11
     */
    methodName: string; // @gotags: bson:"methodName" gorm:"primaryKey"    /**
     * @generated from protobuf field: int32 methodVersion = 12
     */
    methodVersion: number; // @gotags: bson:"methodVersion" gorm:"primaryKey"    /**
     * @generated from protobuf field: int32 successfulCalls = 13
     */
    successfulCalls: number; // @gotags: bson:"successfulCalls"    /**
     * @generated from protobuf field: Uuid ID = 14
     */
    iD?: Uuid;
}
/**
 * @generated from protobuf message MethodInformation
 */
export interface MethodInformation {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // @gotags: bson:"name"    /**
     * @generated from protobuf field: optional string description = 2
     */
    description?: string; // @gotags: bson:"description"    /**
     * @generated from protobuf field: int32 version = 3
     */
    version: number; // @gotags: bson:"version"    /**
     * @generated from protobuf field: string appName = 8
     */
    appName: string; // @gotags: bson:"appName"    /**
     * @generated from protobuf field: string fullMethod = 9
     */
    fullMethod: string; // @gotags: bson:"fullMethod"}
/**
 * @generated from protobuf message ServiceInformation
 */
export interface ServiceInformation {
    /**
     * @generated from protobuf field: string hostAddress = 1
     */
    hostAddress: string; // @gotags: bson:"hostAddress"    /**
     * @generated from protobuf field: string hostName = 2
     */
    hostName: string; // @gotags: bson:"hostName"    /**
     * @generated from protobuf field: int32 port = 3
     */
    port: number; // @gotags: bson:"port"    /**
     * @generated from protobuf field: string serviceName = 4
     */
    serviceName: string; // @gotags: bson:"serviceName"    /**
     * @generated from protobuf field: string serviceVersion = 5
     */
    serviceVersion: string; // @gotags: bson:"serviceVersion"    /**
     * @generated from protobuf field: int64 startedTime = 6
     */
    startedTime: string; // @gotags: bson:"startedTime"    /**
     * @generated from protobuf field: optional string description = 7
     */
    description?: string; // @gotags: bson:"description"    /**
     * @generated from protobuf field: repeated MethodInformation methodInformation = 8
     */
    methodInformation: MethodInformation[]; // @gotags: bson:"serviceInformation"    /**
     * @generated from protobuf field: ObjectId id = 9
     */
    id?: ObjectId;
}
/**
 * @generated from protobuf message AppInformation
 */
export interface AppInformation {
    /**
     * @generated from protobuf field: int32 pid = 1
     */
    pid: number;
    /**
     * @generated from protobuf field: string applicationName = 2
     */
    applicationName: string;
    /**
     * @generated from protobuf field: string version = 3
     */
    version: string;
    /**
     * @generated from protobuf field: int64 startedTime = 4
     */
    startedTime: string;
}
/**
 * @generated from protobuf message RequestHeader
 */
export interface RequestHeader {
    /**
     * @generated from protobuf field: string senderAddress = 1
     */
    senderAddress: string;
    /**
     * @generated from protobuf field: string senderId = 2
     */
    senderId: string;
    /**
     * @generated from protobuf field: string user = 3
     */
    user: string;
    /**
     * @generated from protobuf field: optional Comment comment = 4
     */
    comment?: Comment;
    /**
     * @generated from protobuf field: optional string messageType = 5
     */
    messageType?: string;
    /**
     * @generated from protobuf field: optional string token = 6
     */
    token?: string;
}
/**
 * @generated from protobuf message Comment
 */
export interface Comment {
    /**
     * @generated from protobuf field: int64 ID = 1
     */
    iD: string; // @gotags: gorm:"primaryKey;autoIncrement"    /**
     * @generated from protobuf field: int64 createdDate = 2
     */
    createdDate: string; // @gotags: gorm:"autoCreateTime:milli"    /**
     * @generated from protobuf field: string createdBy = 3
     */
    createdBy: string;
    /**
     * int64 createdFor = 4;
     *
     * @generated from protobuf field: string relatedTable = 5
     */
    relatedTable: string;
    /**
     * @generated from protobuf field: string actionType = 6
     */
    actionType: string;
    /**
     * @generated from protobuf field: string comment = 7
     */
    comment: string;
}
/**
 * @generated from protobuf message ReplyHeader
 */
export interface ReplyHeader {
    /**
     * @generated from protobuf field: string senderAddress = 1
     */
    senderAddress: string;
    /**
     * @generated from protobuf field: string senderId = 2
     */
    senderId: string;
    /**
     * @generated from protobuf field: string errorMessage = 3
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: bool successful = 4
     */
    successful: boolean;
    /**
     * @generated from protobuf field: int32 errorCode = 5
     */
    errorCode: number;
    /**
     * @generated from protobuf field: int64 timeStamp = 6
     */
    timeStamp: string;
    /**
     * @generated from protobuf field: string service = 7
     */
    service: string;
}
/**
 * @generated from protobuf message ErrorInformation
 */
export interface ErrorInformation {
    /**
     * @generated from protobuf field: string errorMessage = 1
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: int32 errorCode = 2
     */
    errorCode: number;
    /**
     * @generated from protobuf field: string serviceName = 3
     */
    serviceName: string;
    /**
     * @generated from protobuf field: string serviceVersion = 4
     */
    serviceVersion: string;
    /**
     * @generated from protobuf field: string methodName = 5
     */
    methodName: string;
    /**
     * @generated from protobuf field: int32 methodVersion = 6
     */
    methodVersion: number;
}
/**
 * @generated from protobuf message FilterCondition
 */
export interface FilterCondition {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: string value = 2
     */
    value: string;
    /**
     * @generated from protobuf field: FilterFunction function = 3
     */
    function: FilterFunction;
    /**
     * @generated from protobuf field: optional string connector = 4
     */
    connector?: string;
    /**
     * @generated from protobuf field: string dataType = 5
     */
    dataType: string;
}
/**
 * @generated from protobuf enum ErrorCode
 */
export enum ErrorCode {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: DATABASE_ERROR = 1;
     */
    DATABASE_ERROR = 1,
    /**
     * @generated from protobuf enum value: MARSHAL_ERROR = 2;
     */
    MARSHAL_ERROR = 2,
    /**
     * @generated from protobuf enum value: UNMARSHAL_ERROR = 3;
     */
    UNMARSHAL_ERROR = 3,
    /**
     * @generated from protobuf enum value: UNDEFINED_ERROR = 4;
     */
    UNDEFINED_ERROR = 4,
    /**
     * @generated from protobuf enum value: INVALID_ID_ERROR = 5;
     */
    INVALID_ID_ERROR = 5,
    /**
     * @generated from protobuf enum value: INSUFFICIENT_PERMISSIONS_ERROR = 6;
     */
    INSUFFICIENT_PERMISSIONS_ERROR = 6,
    /**
     * @generated from protobuf enum value: MISSING_PARAMETER_ERROR = 7;
     */
    MISSING_PARAMETER_ERROR = 7,
    /**
     * @generated from protobuf enum value: ALREADY_LOGGED_IN = 8;
     */
    ALREADY_LOGGED_IN = 8
}
/**
 * @generated from protobuf enum FilterFunction
 */
export enum FilterFunction {
    /**
     * @generated from protobuf enum value: EQUALS = 0;
     */
    EQUALS = 0,
    /**
     * @generated from protobuf enum value: LTE = 1;
     */
    LTE = 1,
    /**
     * @generated from protobuf enum value: GTE = 2;
     */
    GTE = 2,
    /**
     * @generated from protobuf enum value: LT = 3;
     */
    LT = 3,
    /**
     * @generated from protobuf enum value: GT = 4;
     */
    GT = 4,
    /**
     * @generated from protobuf enum value: IN = 5;
     */
    IN = 5,
    /**
     * @generated from protobuf enum value: CONTAINS = 6;
     */
    CONTAINS = 6,
    /**
     * @generated from protobuf enum value: LIKE = 7;
     */
    LIKE = 7,
    /**
     * @generated from protobuf enum value: NOT_EQUALS = 8;
     */
    NOT_EQUALS = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class ObjectId$Type extends MessageType<ObjectId> {
    constructor() {
        super("ObjectId", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ObjectId>): ObjectId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        if (value !== undefined)
            reflectionMergePartial<ObjectId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectId): ObjectId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ObjectId
 */
export const ObjectId = new ObjectId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Term$Type extends MessageType<Term> {
    constructor() {
        super("Term", [
            { no: 1, name: "Term", kind: "scalar", jsonName: "Term", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "Frequency", kind: "scalar", jsonName: "Frequency", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ZipfValue", kind: "scalar", jsonName: "ZipfValue", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "Stemmed", kind: "scalar", jsonName: "Stemmed", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Term>): Term {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.term = "";
        message.frequency = 0;
        message.zipfValue = 0;
        message.stemmed = false;
        if (value !== undefined)
            reflectionMergePartial<Term>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Term): Term {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Term */ 1:
                    message.term = reader.string();
                    break;
                case /* int32 Frequency */ 2:
                    message.frequency = reader.int32();
                    break;
                case /* double ZipfValue */ 3:
                    message.zipfValue = reader.double();
                    break;
                case /* bool Stemmed */ 4:
                    message.stemmed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Term, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Term = 1; */
        if (message.term !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.term);
        /* int32 Frequency = 2; */
        if (message.frequency !== 0)
            writer.tag(2, WireType.Varint).int32(message.frequency);
        /* double ZipfValue = 3; */
        if (message.zipfValue !== 0)
            writer.tag(3, WireType.Bit64).double(message.zipfValue);
        /* bool Stemmed = 4; */
        if (message.stemmed !== false)
            writer.tag(4, WireType.Varint).bool(message.stemmed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Term
 */
export const Term = new Term$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlRequestReply$Type extends MessageType<SqlRequestReply> {
    constructor() {
        super("SqlRequestReply", [
            { no: 1, name: "ID", kind: "message", jsonName: "ID", T: () => Uuid },
            { no: 2, name: "request", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "methodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "methodVersion", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "fullMethodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "successful", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "createdAt", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SqlRequestReply>): SqlRequestReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.request = "";
        message.reply = "";
        message.serviceName = "";
        message.address = "";
        message.port = 0;
        message.version = "";
        message.methodName = "";
        message.methodVersion = 0;
        message.fullMethodName = "";
        message.appName = "";
        message.successful = false;
        message.createdAt = "0";
        if (value !== undefined)
            reflectionMergePartial<SqlRequestReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlRequestReply): SqlRequestReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Uuid ID */ 1:
                    message.iD = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.iD);
                    break;
                case /* string request */ 2:
                    message.request = reader.string();
                    break;
                case /* string reply */ 3:
                    message.reply = reader.string();
                    break;
                case /* string serviceName */ 4:
                    message.serviceName = reader.string();
                    break;
                case /* string address */ 5:
                    message.address = reader.string();
                    break;
                case /* int32 port */ 6:
                    message.port = reader.int32();
                    break;
                case /* string version */ 7:
                    message.version = reader.string();
                    break;
                case /* string methodName */ 8:
                    message.methodName = reader.string();
                    break;
                case /* int32 methodVersion */ 9:
                    message.methodVersion = reader.int32();
                    break;
                case /* string fullMethodName */ 10:
                    message.fullMethodName = reader.string();
                    break;
                case /* string appName */ 11:
                    message.appName = reader.string();
                    break;
                case /* bool successful */ 12:
                    message.successful = reader.bool();
                    break;
                case /* int64 createdAt */ 13:
                    message.createdAt = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlRequestReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Uuid ID = 1; */
        if (message.iD)
            Uuid.internalBinaryWrite(message.iD, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string request = 2; */
        if (message.request !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.request);
        /* string reply = 3; */
        if (message.reply !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reply);
        /* string serviceName = 4; */
        if (message.serviceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serviceName);
        /* string address = 5; */
        if (message.address !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.address);
        /* int32 port = 6; */
        if (message.port !== 0)
            writer.tag(6, WireType.Varint).int32(message.port);
        /* string version = 7; */
        if (message.version !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.version);
        /* string methodName = 8; */
        if (message.methodName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.methodName);
        /* int32 methodVersion = 9; */
        if (message.methodVersion !== 0)
            writer.tag(9, WireType.Varint).int32(message.methodVersion);
        /* string fullMethodName = 10; */
        if (message.fullMethodName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.fullMethodName);
        /* string appName = 11; */
        if (message.appName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.appName);
        /* bool successful = 12; */
        if (message.successful !== false)
            writer.tag(12, WireType.Varint).bool(message.successful);
        /* int64 createdAt = 13; */
        if (message.createdAt !== "0")
            writer.tag(13, WireType.Varint).int64(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SqlRequestReply
 */
export const SqlRequestReply = new SqlRequestReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Heartbeat$Type extends MessageType<Heartbeat> {
    constructor() {
        super("Heartbeat", [
            { no: 1, name: "currentTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "appVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hostAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "numGoRoutines", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "numCpu", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "goOs", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "goArch", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "goVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "allocBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 13, name: "totalAllocBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 14, name: "sysBytes", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
            { no: 15, name: "lookups", kind: "scalar", T: 4 /*ScalarType.UINT64*/ }
        ]);
    }
    create(value?: PartialMessage<Heartbeat>): Heartbeat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.currentTime = "0";
        message.startedTime = "0";
        message.appName = "";
        message.appVersion = "";
        message.hostAddress = "";
        message.port = 0;
        message.numGoRoutines = 0;
        message.numCpu = 0;
        message.goOs = "";
        message.goArch = "";
        message.goVersion = "";
        message.allocBytes = "0";
        message.totalAllocBytes = "0";
        message.sysBytes = "0";
        message.lookups = "0";
        if (value !== undefined)
            reflectionMergePartial<Heartbeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Heartbeat): Heartbeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 currentTime */ 1:
                    message.currentTime = reader.int64().toString();
                    break;
                case /* int64 startedTime */ 2:
                    message.startedTime = reader.int64().toString();
                    break;
                case /* string appName */ 3:
                    message.appName = reader.string();
                    break;
                case /* string appVersion */ 4:
                    message.appVersion = reader.string();
                    break;
                case /* string hostAddress */ 5:
                    message.hostAddress = reader.string();
                    break;
                case /* int32 port */ 6:
                    message.port = reader.int32();
                    break;
                case /* int32 numGoRoutines */ 7:
                    message.numGoRoutines = reader.int32();
                    break;
                case /* int32 numCpu */ 8:
                    message.numCpu = reader.int32();
                    break;
                case /* string goOs */ 9:
                    message.goOs = reader.string();
                    break;
                case /* string goArch */ 10:
                    message.goArch = reader.string();
                    break;
                case /* string goVersion */ 11:
                    message.goVersion = reader.string();
                    break;
                case /* uint64 allocBytes */ 12:
                    message.allocBytes = reader.uint64().toString();
                    break;
                case /* uint64 totalAllocBytes */ 13:
                    message.totalAllocBytes = reader.uint64().toString();
                    break;
                case /* uint64 sysBytes */ 14:
                    message.sysBytes = reader.uint64().toString();
                    break;
                case /* uint64 lookups */ 15:
                    message.lookups = reader.uint64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Heartbeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 currentTime = 1; */
        if (message.currentTime !== "0")
            writer.tag(1, WireType.Varint).int64(message.currentTime);
        /* int64 startedTime = 2; */
        if (message.startedTime !== "0")
            writer.tag(2, WireType.Varint).int64(message.startedTime);
        /* string appName = 3; */
        if (message.appName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.appName);
        /* string appVersion = 4; */
        if (message.appVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.appVersion);
        /* string hostAddress = 5; */
        if (message.hostAddress !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hostAddress);
        /* int32 port = 6; */
        if (message.port !== 0)
            writer.tag(6, WireType.Varint).int32(message.port);
        /* int32 numGoRoutines = 7; */
        if (message.numGoRoutines !== 0)
            writer.tag(7, WireType.Varint).int32(message.numGoRoutines);
        /* int32 numCpu = 8; */
        if (message.numCpu !== 0)
            writer.tag(8, WireType.Varint).int32(message.numCpu);
        /* string goOs = 9; */
        if (message.goOs !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.goOs);
        /* string goArch = 10; */
        if (message.goArch !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.goArch);
        /* string goVersion = 11; */
        if (message.goVersion !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.goVersion);
        /* uint64 allocBytes = 12; */
        if (message.allocBytes !== "0")
            writer.tag(12, WireType.Varint).uint64(message.allocBytes);
        /* uint64 totalAllocBytes = 13; */
        if (message.totalAllocBytes !== "0")
            writer.tag(13, WireType.Varint).uint64(message.totalAllocBytes);
        /* uint64 sysBytes = 14; */
        if (message.sysBytes !== "0")
            writer.tag(14, WireType.Varint).uint64(message.sysBytes);
        /* uint64 lookups = 15; */
        if (message.lookups !== "0")
            writer.tag(15, WireType.Varint).uint64(message.lookups);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Heartbeat
 */
export const Heartbeat = new Heartbeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Uuid$Type extends MessageType<Uuid> {
    constructor() {
        super("Uuid", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Uuid>): Uuid {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Uuid>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Uuid): Uuid {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Uuid, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Uuid
 */
export const Uuid = new Uuid$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MethodMetric$Type extends MessageType<MethodMetric> {
    constructor() {
        super("MethodMetric", [
            { no: 1, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "appVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "endTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "numberOfCalls", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "avgDuration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "sumDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "minDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 9, name: "maxDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 10, name: "lastUpdate", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "methodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "methodVersion", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "successfulCalls", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "id", kind: "message", T: () => ObjectId, options: { tags: "bson:\"_id,omitempty\"" } }
        ]);
    }
    create(value?: PartialMessage<MethodMetric>): MethodMetric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appName = "";
        message.appVersion = "";
        message.startedTime = "0";
        message.endTime = "0";
        message.numberOfCalls = "0";
        message.avgDuration = 0;
        message.sumDuration = "0";
        message.minDuration = "0";
        message.maxDuration = "0";
        message.lastUpdate = "0";
        message.methodName = "";
        message.methodVersion = 0;
        message.successfulCalls = 0;
        if (value !== undefined)
            reflectionMergePartial<MethodMetric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MethodMetric): MethodMetric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string appName */ 1:
                    message.appName = reader.string();
                    break;
                case /* string appVersion */ 2:
                    message.appVersion = reader.string();
                    break;
                case /* int64 startedTime */ 3:
                    message.startedTime = reader.int64().toString();
                    break;
                case /* int64 endTime */ 4:
                    message.endTime = reader.int64().toString();
                    break;
                case /* int64 numberOfCalls */ 5:
                    message.numberOfCalls = reader.int64().toString();
                    break;
                case /* float avgDuration */ 6:
                    message.avgDuration = reader.float();
                    break;
                case /* int64 sumDuration */ 7:
                    message.sumDuration = reader.int64().toString();
                    break;
                case /* int64 minDuration */ 8:
                    message.minDuration = reader.int64().toString();
                    break;
                case /* int64 maxDuration */ 9:
                    message.maxDuration = reader.int64().toString();
                    break;
                case /* int64 lastUpdate */ 10:
                    message.lastUpdate = reader.int64().toString();
                    break;
                case /* string methodName */ 11:
                    message.methodName = reader.string();
                    break;
                case /* int32 methodVersion */ 12:
                    message.methodVersion = reader.int32();
                    break;
                case /* int32 successfulCalls */ 13:
                    message.successfulCalls = reader.int32();
                    break;
                case /* ObjectId id */ 14:
                    message.id = ObjectId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MethodMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string appName = 1; */
        if (message.appName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appName);
        /* string appVersion = 2; */
        if (message.appVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.appVersion);
        /* int64 startedTime = 3; */
        if (message.startedTime !== "0")
            writer.tag(3, WireType.Varint).int64(message.startedTime);
        /* int64 endTime = 4; */
        if (message.endTime !== "0")
            writer.tag(4, WireType.Varint).int64(message.endTime);
        /* int64 numberOfCalls = 5; */
        if (message.numberOfCalls !== "0")
            writer.tag(5, WireType.Varint).int64(message.numberOfCalls);
        /* float avgDuration = 6; */
        if (message.avgDuration !== 0)
            writer.tag(6, WireType.Bit32).float(message.avgDuration);
        /* int64 sumDuration = 7; */
        if (message.sumDuration !== "0")
            writer.tag(7, WireType.Varint).int64(message.sumDuration);
        /* int64 minDuration = 8; */
        if (message.minDuration !== "0")
            writer.tag(8, WireType.Varint).int64(message.minDuration);
        /* int64 maxDuration = 9; */
        if (message.maxDuration !== "0")
            writer.tag(9, WireType.Varint).int64(message.maxDuration);
        /* int64 lastUpdate = 10; */
        if (message.lastUpdate !== "0")
            writer.tag(10, WireType.Varint).int64(message.lastUpdate);
        /* string methodName = 11; */
        if (message.methodName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.methodName);
        /* int32 methodVersion = 12; */
        if (message.methodVersion !== 0)
            writer.tag(12, WireType.Varint).int32(message.methodVersion);
        /* int32 successfulCalls = 13; */
        if (message.successfulCalls !== 0)
            writer.tag(13, WireType.Varint).int32(message.successfulCalls);
        /* ObjectId id = 14; */
        if (message.id)
            ObjectId.internalBinaryWrite(message.id, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MethodMetric
 */
export const MethodMetric = new MethodMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlMethodMetric$Type extends MessageType<SqlMethodMetric> {
    constructor() {
        super("SqlMethodMetric", [
            { no: 1, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "appVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "endTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 5, name: "numberOfCalls", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 6, name: "avgDuration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "sumDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 8, name: "minDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 9, name: "maxDuration", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 10, name: "lastUpdate", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 11, name: "methodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "methodVersion", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "successfulCalls", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "ID", kind: "message", jsonName: "ID", T: () => Uuid }
        ]);
    }
    create(value?: PartialMessage<SqlMethodMetric>): SqlMethodMetric {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appName = "";
        message.appVersion = "";
        message.startedTime = "0";
        message.endTime = "0";
        message.numberOfCalls = "0";
        message.avgDuration = 0;
        message.sumDuration = "0";
        message.minDuration = "0";
        message.maxDuration = "0";
        message.lastUpdate = "0";
        message.methodName = "";
        message.methodVersion = 0;
        message.successfulCalls = 0;
        if (value !== undefined)
            reflectionMergePartial<SqlMethodMetric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlMethodMetric): SqlMethodMetric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string appName */ 1:
                    message.appName = reader.string();
                    break;
                case /* string appVersion */ 2:
                    message.appVersion = reader.string();
                    break;
                case /* int64 startedTime */ 3:
                    message.startedTime = reader.int64().toString();
                    break;
                case /* int64 endTime */ 4:
                    message.endTime = reader.int64().toString();
                    break;
                case /* int64 numberOfCalls */ 5:
                    message.numberOfCalls = reader.int64().toString();
                    break;
                case /* float avgDuration */ 6:
                    message.avgDuration = reader.float();
                    break;
                case /* int64 sumDuration */ 7:
                    message.sumDuration = reader.int64().toString();
                    break;
                case /* int64 minDuration */ 8:
                    message.minDuration = reader.int64().toString();
                    break;
                case /* int64 maxDuration */ 9:
                    message.maxDuration = reader.int64().toString();
                    break;
                case /* int64 lastUpdate */ 10:
                    message.lastUpdate = reader.int64().toString();
                    break;
                case /* string methodName */ 11:
                    message.methodName = reader.string();
                    break;
                case /* int32 methodVersion */ 12:
                    message.methodVersion = reader.int32();
                    break;
                case /* int32 successfulCalls */ 13:
                    message.successfulCalls = reader.int32();
                    break;
                case /* Uuid ID */ 14:
                    message.iD = Uuid.internalBinaryRead(reader, reader.uint32(), options, message.iD);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlMethodMetric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string appName = 1; */
        if (message.appName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.appName);
        /* string appVersion = 2; */
        if (message.appVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.appVersion);
        /* int64 startedTime = 3; */
        if (message.startedTime !== "0")
            writer.tag(3, WireType.Varint).int64(message.startedTime);
        /* int64 endTime = 4; */
        if (message.endTime !== "0")
            writer.tag(4, WireType.Varint).int64(message.endTime);
        /* int64 numberOfCalls = 5; */
        if (message.numberOfCalls !== "0")
            writer.tag(5, WireType.Varint).int64(message.numberOfCalls);
        /* float avgDuration = 6; */
        if (message.avgDuration !== 0)
            writer.tag(6, WireType.Bit32).float(message.avgDuration);
        /* int64 sumDuration = 7; */
        if (message.sumDuration !== "0")
            writer.tag(7, WireType.Varint).int64(message.sumDuration);
        /* int64 minDuration = 8; */
        if (message.minDuration !== "0")
            writer.tag(8, WireType.Varint).int64(message.minDuration);
        /* int64 maxDuration = 9; */
        if (message.maxDuration !== "0")
            writer.tag(9, WireType.Varint).int64(message.maxDuration);
        /* int64 lastUpdate = 10; */
        if (message.lastUpdate !== "0")
            writer.tag(10, WireType.Varint).int64(message.lastUpdate);
        /* string methodName = 11; */
        if (message.methodName !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.methodName);
        /* int32 methodVersion = 12; */
        if (message.methodVersion !== 0)
            writer.tag(12, WireType.Varint).int32(message.methodVersion);
        /* int32 successfulCalls = 13; */
        if (message.successfulCalls !== 0)
            writer.tag(13, WireType.Varint).int32(message.successfulCalls);
        /* Uuid ID = 14; */
        if (message.iD)
            Uuid.internalBinaryWrite(message.iD, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SqlMethodMetric
 */
export const SqlMethodMetric = new SqlMethodMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MethodInformation$Type extends MessageType<MethodInformation> {
    constructor() {
        super("MethodInformation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "appName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "fullMethod", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MethodInformation>): MethodInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.version = 0;
        message.appName = "";
        message.fullMethod = "";
        if (value !== undefined)
            reflectionMergePartial<MethodInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MethodInformation): MethodInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string description */ 2:
                    message.description = reader.string();
                    break;
                case /* int32 version */ 3:
                    message.version = reader.int32();
                    break;
                case /* string appName */ 8:
                    message.appName = reader.string();
                    break;
                case /* string fullMethod */ 9:
                    message.fullMethod = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MethodInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string description = 2; */
        if (message.description !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* int32 version = 3; */
        if (message.version !== 0)
            writer.tag(3, WireType.Varint).int32(message.version);
        /* string appName = 8; */
        if (message.appName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.appName);
        /* string fullMethod = 9; */
        if (message.fullMethod !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.fullMethod);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MethodInformation
 */
export const MethodInformation = new MethodInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInformation$Type extends MessageType<ServiceInformation> {
    constructor() {
        super("ServiceInformation", [
            { no: 1, name: "hostAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "serviceVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "description", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "methodInformation", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MethodInformation },
            { no: 9, name: "id", kind: "message", T: () => ObjectId, options: { tags: "bson:\"_id,omitempty\"" } }
        ]);
    }
    create(value?: PartialMessage<ServiceInformation>): ServiceInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hostAddress = "";
        message.hostName = "";
        message.port = 0;
        message.serviceName = "";
        message.serviceVersion = "";
        message.startedTime = "0";
        message.methodInformation = [];
        if (value !== undefined)
            reflectionMergePartial<ServiceInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServiceInformation): ServiceInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hostAddress */ 1:
                    message.hostAddress = reader.string();
                    break;
                case /* string hostName */ 2:
                    message.hostName = reader.string();
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* string serviceName */ 4:
                    message.serviceName = reader.string();
                    break;
                case /* string serviceVersion */ 5:
                    message.serviceVersion = reader.string();
                    break;
                case /* int64 startedTime */ 6:
                    message.startedTime = reader.int64().toString();
                    break;
                case /* optional string description */ 7:
                    message.description = reader.string();
                    break;
                case /* repeated MethodInformation methodInformation */ 8:
                    message.methodInformation.push(MethodInformation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* ObjectId id */ 9:
                    message.id = ObjectId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServiceInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hostAddress = 1; */
        if (message.hostAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hostAddress);
        /* string hostName = 2; */
        if (message.hostName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostName);
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* string serviceName = 4; */
        if (message.serviceName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serviceName);
        /* string serviceVersion = 5; */
        if (message.serviceVersion !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.serviceVersion);
        /* int64 startedTime = 6; */
        if (message.startedTime !== "0")
            writer.tag(6, WireType.Varint).int64(message.startedTime);
        /* optional string description = 7; */
        if (message.description !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.description);
        /* repeated MethodInformation methodInformation = 8; */
        for (let i = 0; i < message.methodInformation.length; i++)
            MethodInformation.internalBinaryWrite(message.methodInformation[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* ObjectId id = 9; */
        if (message.id)
            ObjectId.internalBinaryWrite(message.id, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ServiceInformation
 */
export const ServiceInformation = new ServiceInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppInformation$Type extends MessageType<AppInformation> {
    constructor() {
        super("AppInformation", [
            { no: 1, name: "pid", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "applicationName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "startedTime", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<AppInformation>): AppInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.pid = 0;
        message.applicationName = "";
        message.version = "";
        message.startedTime = "0";
        if (value !== undefined)
            reflectionMergePartial<AppInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppInformation): AppInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 pid */ 1:
                    message.pid = reader.int32();
                    break;
                case /* string applicationName */ 2:
                    message.applicationName = reader.string();
                    break;
                case /* string version */ 3:
                    message.version = reader.string();
                    break;
                case /* int64 startedTime */ 4:
                    message.startedTime = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 pid = 1; */
        if (message.pid !== 0)
            writer.tag(1, WireType.Varint).int32(message.pid);
        /* string applicationName = 2; */
        if (message.applicationName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.applicationName);
        /* string version = 3; */
        if (message.version !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.version);
        /* int64 startedTime = 4; */
        if (message.startedTime !== "0")
            writer.tag(4, WireType.Varint).int64(message.startedTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AppInformation
 */
export const AppInformation = new AppInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestHeader$Type extends MessageType<RequestHeader> {
    constructor() {
        super("RequestHeader", [
            { no: 1, name: "senderAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "comment", kind: "message", T: () => Comment },
            { no: 5, name: "messageType", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestHeader>): RequestHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderAddress = "";
        message.senderId = "";
        message.user = "";
        if (value !== undefined)
            reflectionMergePartial<RequestHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestHeader): RequestHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string senderAddress */ 1:
                    message.senderAddress = reader.string();
                    break;
                case /* string senderId */ 2:
                    message.senderId = reader.string();
                    break;
                case /* string user */ 3:
                    message.user = reader.string();
                    break;
                case /* optional Comment comment */ 4:
                    message.comment = Comment.internalBinaryRead(reader, reader.uint32(), options, message.comment);
                    break;
                case /* optional string messageType */ 5:
                    message.messageType = reader.string();
                    break;
                case /* optional string token */ 6:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string senderAddress = 1; */
        if (message.senderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.senderAddress);
        /* string senderId = 2; */
        if (message.senderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderId);
        /* string user = 3; */
        if (message.user !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.user);
        /* optional Comment comment = 4; */
        if (message.comment)
            Comment.internalBinaryWrite(message.comment, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional string messageType = 5; */
        if (message.messageType !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.messageType);
        /* optional string token = 6; */
        if (message.token !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RequestHeader
 */
export const RequestHeader = new RequestHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Comment$Type extends MessageType<Comment> {
    constructor() {
        super("Comment", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "createdDate", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "createdBy", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "relatedTable", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "actionType", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "comment", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Comment>): Comment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "0";
        message.createdDate = "0";
        message.createdBy = "";
        message.relatedTable = "";
        message.actionType = "";
        message.comment = "";
        if (value !== undefined)
            reflectionMergePartial<Comment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Comment): Comment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 ID */ 1:
                    message.iD = reader.int64().toString();
                    break;
                case /* int64 createdDate */ 2:
                    message.createdDate = reader.int64().toString();
                    break;
                case /* string createdBy */ 3:
                    message.createdBy = reader.string();
                    break;
                case /* string relatedTable */ 5:
                    message.relatedTable = reader.string();
                    break;
                case /* string actionType */ 6:
                    message.actionType = reader.string();
                    break;
                case /* string comment */ 7:
                    message.comment = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Comment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 ID = 1; */
        if (message.iD !== "0")
            writer.tag(1, WireType.Varint).int64(message.iD);
        /* int64 createdDate = 2; */
        if (message.createdDate !== "0")
            writer.tag(2, WireType.Varint).int64(message.createdDate);
        /* string createdBy = 3; */
        if (message.createdBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.createdBy);
        /* string relatedTable = 5; */
        if (message.relatedTable !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.relatedTable);
        /* string actionType = 6; */
        if (message.actionType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.actionType);
        /* string comment = 7; */
        if (message.comment !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.comment);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Comment
 */
export const Comment = new Comment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReplyHeader$Type extends MessageType<ReplyHeader> {
    constructor() {
        super("ReplyHeader", [
            { no: 1, name: "senderAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "senderId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "successful", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "errorCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "timeStamp", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 7, name: "service", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ReplyHeader>): ReplyHeader {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.senderAddress = "";
        message.senderId = "";
        message.errorMessage = "";
        message.successful = false;
        message.errorCode = 0;
        message.timeStamp = "0";
        message.service = "";
        if (value !== undefined)
            reflectionMergePartial<ReplyHeader>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReplyHeader): ReplyHeader {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string senderAddress */ 1:
                    message.senderAddress = reader.string();
                    break;
                case /* string senderId */ 2:
                    message.senderId = reader.string();
                    break;
                case /* string errorMessage */ 3:
                    message.errorMessage = reader.string();
                    break;
                case /* bool successful */ 4:
                    message.successful = reader.bool();
                    break;
                case /* int32 errorCode */ 5:
                    message.errorCode = reader.int32();
                    break;
                case /* int64 timeStamp */ 6:
                    message.timeStamp = reader.int64().toString();
                    break;
                case /* string service */ 7:
                    message.service = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReplyHeader, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string senderAddress = 1; */
        if (message.senderAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.senderAddress);
        /* string senderId = 2; */
        if (message.senderId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.senderId);
        /* string errorMessage = 3; */
        if (message.errorMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.errorMessage);
        /* bool successful = 4; */
        if (message.successful !== false)
            writer.tag(4, WireType.Varint).bool(message.successful);
        /* int32 errorCode = 5; */
        if (message.errorCode !== 0)
            writer.tag(5, WireType.Varint).int32(message.errorCode);
        /* int64 timeStamp = 6; */
        if (message.timeStamp !== "0")
            writer.tag(6, WireType.Varint).int64(message.timeStamp);
        /* string service = 7; */
        if (message.service !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.service);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReplyHeader
 */
export const ReplyHeader = new ReplyHeader$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorInformation$Type extends MessageType<ErrorInformation> {
    constructor() {
        super("ErrorInformation", [
            { no: 1, name: "errorMessage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "errorCode", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "serviceName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "serviceVersion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "methodName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "methodVersion", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorInformation>): ErrorInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.errorMessage = "";
        message.errorCode = 0;
        message.serviceName = "";
        message.serviceVersion = "";
        message.methodName = "";
        message.methodVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<ErrorInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorInformation): ErrorInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string errorMessage */ 1:
                    message.errorMessage = reader.string();
                    break;
                case /* int32 errorCode */ 2:
                    message.errorCode = reader.int32();
                    break;
                case /* string serviceName */ 3:
                    message.serviceName = reader.string();
                    break;
                case /* string serviceVersion */ 4:
                    message.serviceVersion = reader.string();
                    break;
                case /* string methodName */ 5:
                    message.methodName = reader.string();
                    break;
                case /* int32 methodVersion */ 6:
                    message.methodVersion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string errorMessage = 1; */
        if (message.errorMessage !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.errorMessage);
        /* int32 errorCode = 2; */
        if (message.errorCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.errorCode);
        /* string serviceName = 3; */
        if (message.serviceName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.serviceName);
        /* string serviceVersion = 4; */
        if (message.serviceVersion !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.serviceVersion);
        /* string methodName = 5; */
        if (message.methodName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.methodName);
        /* int32 methodVersion = 6; */
        if (message.methodVersion !== 0)
            writer.tag(6, WireType.Varint).int32(message.methodVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ErrorInformation
 */
export const ErrorInformation = new ErrorInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterCondition$Type extends MessageType<FilterCondition> {
    constructor() {
        super("FilterCondition", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "function", kind: "enum", T: () => ["FilterFunction", FilterFunction] },
            { no: 4, name: "connector", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "dataType", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FilterCondition>): FilterCondition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        message.value = "";
        message.function = 0;
        message.dataType = "";
        if (value !== undefined)
            reflectionMergePartial<FilterCondition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterCondition): FilterCondition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                case /* FilterFunction function */ 3:
                    message.function = reader.int32();
                    break;
                case /* optional string connector */ 4:
                    message.connector = reader.string();
                    break;
                case /* string dataType */ 5:
                    message.dataType = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterCondition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        /* FilterFunction function = 3; */
        if (message.function !== 0)
            writer.tag(3, WireType.Varint).int32(message.function);
        /* optional string connector = 4; */
        if (message.connector !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.connector);
        /* string dataType = 5; */
        if (message.dataType !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.dataType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FilterCondition
 */
export const FilterCondition = new FilterCondition$Type();
