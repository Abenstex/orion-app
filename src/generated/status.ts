// @generated by protobuf-ts 2.11.1 with parameter long_type_bigint
// @generated from protobuf file "status.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EventHeader } from "./orion_common";
import { ReplyHeader } from "./orion_common";
import { RequestFilter } from "./orion_common";
import { RequestHeader } from "./orion_common";
import { ObjectType } from "./orion_common";
import { BaseInformation } from "./orion_common";
/**
 * @generated from protobuf message Status
 */
export interface Status {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: ObjectType allowedForType = 2
     */
    allowedForType: ObjectType;
    /**
     * @generated from protobuf field: bool isUsable = 3
     */
    isUsable: boolean;
}
/**
 * @generated from protobuf message StatusTransitionRule
 */
export interface StatusTransitionRule {
    /**
     * @generated from protobuf field: BaseInformation baseInformation = 1
     */
    baseInformation?: BaseInformation;
    /**
     * @generated from protobuf field: Status fromStatus = 2
     */
    fromStatus?: Status;
    /**
     * @generated from protobuf field: repeated Status possibleNextStatus = 3
     */
    possibleNextStatus: Status[];
}
/**
 * @generated from protobuf message AddStatusRequest
 */
export interface AddStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message UpdateStatusRequest
 */
export interface UpdateStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message ChangeStatusRequest
 */
export interface ChangeStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: StatusChangeInformation info = 2
     */
    info?: StatusChangeInformation;
}
/**
 * @generated from protobuf message StatusChangeInformation
 */
export interface StatusChangeInformation {
    /**
     * @generated from protobuf field: optional int64 entryNo = 1
     */
    entryNo?: bigint;
    /**
     * @generated from protobuf field: string objectId = 2
     */
    objectId: string;
    /**
     * @generated from protobuf field: ObjectType objectType = 3
     */
    objectType: ObjectType;
    /**
     * @generated from protobuf field: string fromStatusId = 4
     */
    fromStatusId: string;
    /**
     * @generated from protobuf field: string toStatusId = 5
     */
    toStatusId: string;
    /**
     * @generated from protobuf field: string fromStatusName = 6
     */
    fromStatusName: string;
    /**
     * @generated from protobuf field: string toStatusName = 7
     */
    toStatusName: string;
    /**
     * @generated from protobuf field: string objectName = 8
     */
    objectName: string;
}
/**
 * @generated from protobuf message DeleteStatusRequest
 */
export interface DeleteStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string statusId = 2
     */
    statusId: string;
}
/**
 * @generated from protobuf message GetStatusRequest
 */
export interface GetStatusRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message GetStatusReply
 */
export interface GetStatusReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated Status status = 2
     */
    status: Status[];
}
/**
 * @generated from protobuf message StatusSavedEvent
 */
export interface StatusSavedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: Status status = 2
     */
    status?: Status;
}
/**
 * @generated from protobuf message StatusChangedEvent
 */
export interface StatusChangedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: StatusChangeInformation statusChangeInformation = 2
     */
    statusChangeInformation?: StatusChangeInformation;
}
/**
 * @generated from protobuf message StatusDeletedEvent
 */
export interface StatusDeletedEvent {
    /**
     * @generated from protobuf field: EventHeader header = 1
     */
    header?: EventHeader;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
}
/**
 * @generated from protobuf message AddStatusTransitionRuleRequest
 */
export interface AddStatusTransitionRuleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: StatusTransitionRule rule = 2
     */
    rule?: StatusTransitionRule;
}
/**
 * @generated from protobuf message UpdateStatusTransitionRuleRequest
 */
export interface UpdateStatusTransitionRuleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: StatusTransitionRule rule = 2
     */
    rule?: StatusTransitionRule;
}
/**
 * @generated from protobuf message DeleteStatusTransitionRuleRequest
 */
export interface DeleteStatusTransitionRuleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: string ruleId = 2
     */
    ruleId: string;
}
/**
 * @generated from protobuf message GetStatusTransitionRuleRequest
 */
export interface GetStatusTransitionRuleRequest {
    /**
     * @generated from protobuf field: RequestHeader header = 1
     */
    header?: RequestHeader;
    /**
     * @generated from protobuf field: repeated RequestFilter filters = 2
     */
    filters: RequestFilter[];
}
/**
 * @generated from protobuf message GetStatusTransitionRuleReply
 */
export interface GetStatusTransitionRuleReply {
    /**
     * @generated from protobuf field: ReplyHeader header = 1
     */
    header?: ReplyHeader;
    /**
     * @generated from protobuf field: repeated StatusTransitionRule rules = 2
     */
    rules: StatusTransitionRule[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("Status", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "allowedForType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 3, name: "isUsable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.allowedForType = 0;
        message.isUsable = false;
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* ObjectType allowedForType */ 2:
                    message.allowedForType = reader.int32();
                    break;
                case /* bool isUsable */ 3:
                    message.isUsable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ObjectType allowedForType = 2; */
        if (message.allowedForType !== 0)
            writer.tag(2, WireType.Varint).int32(message.allowedForType);
        /* bool isUsable = 3; */
        if (message.isUsable !== false)
            writer.tag(3, WireType.Varint).bool(message.isUsable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Status
 */
export const Status = new Status$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusTransitionRule$Type extends MessageType<StatusTransitionRule> {
    constructor() {
        super("StatusTransitionRule", [
            { no: 1, name: "baseInformation", kind: "message", T: () => BaseInformation },
            { no: 2, name: "fromStatus", kind: "message", T: () => Status },
            { no: 3, name: "possibleNextStatus", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StatusTransitionRule>): StatusTransitionRule {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.possibleNextStatus = [];
        if (value !== undefined)
            reflectionMergePartial<StatusTransitionRule>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusTransitionRule): StatusTransitionRule {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* BaseInformation baseInformation */ 1:
                    message.baseInformation = BaseInformation.internalBinaryRead(reader, reader.uint32(), options, message.baseInformation);
                    break;
                case /* Status fromStatus */ 2:
                    message.fromStatus = Status.internalBinaryRead(reader, reader.uint32(), options, message.fromStatus);
                    break;
                case /* repeated Status possibleNextStatus */ 3:
                    message.possibleNextStatus.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusTransitionRule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* BaseInformation baseInformation = 1; */
        if (message.baseInformation)
            BaseInformation.internalBinaryWrite(message.baseInformation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status fromStatus = 2; */
        if (message.fromStatus)
            Status.internalBinaryWrite(message.fromStatus, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated Status possibleNextStatus = 3; */
        for (let i = 0; i < message.possibleNextStatus.length; i++)
            Status.internalBinaryWrite(message.possibleNextStatus[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusTransitionRule
 */
export const StatusTransitionRule = new StatusTransitionRule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddStatusRequest$Type extends MessageType<AddStatusRequest> {
    constructor() {
        super("AddStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<AddStatusRequest>): AddStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddStatusRequest): AddStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddStatusRequest
 */
export const AddStatusRequest = new AddStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusRequest$Type extends MessageType<UpdateStatusRequest> {
    constructor() {
        super("UpdateStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusRequest>): UpdateStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusRequest): UpdateStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateStatusRequest
 */
export const UpdateStatusRequest = new UpdateStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeStatusRequest$Type extends MessageType<ChangeStatusRequest> {
    constructor() {
        super("ChangeStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "info", kind: "message", T: () => StatusChangeInformation }
        ]);
    }
    create(value?: PartialMessage<ChangeStatusRequest>): ChangeStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ChangeStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeStatusRequest): ChangeStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* StatusChangeInformation info */ 2:
                    message.info = StatusChangeInformation.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StatusChangeInformation info = 2; */
        if (message.info)
            StatusChangeInformation.internalBinaryWrite(message.info, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeStatusRequest
 */
export const ChangeStatusRequest = new ChangeStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusChangeInformation$Type extends MessageType<StatusChangeInformation> {
    constructor() {
        super("StatusChangeInformation", [
            { no: 1, name: "entryNo", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "objectId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "objectType", kind: "enum", T: () => ["ObjectType", ObjectType] },
            { no: 4, name: "fromStatusId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "toStatusId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "fromStatusName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "toStatusName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "objectName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusChangeInformation>): StatusChangeInformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.objectId = "";
        message.objectType = 0;
        message.fromStatusId = "";
        message.toStatusId = "";
        message.fromStatusName = "";
        message.toStatusName = "";
        message.objectName = "";
        if (value !== undefined)
            reflectionMergePartial<StatusChangeInformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusChangeInformation): StatusChangeInformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 entryNo */ 1:
                    message.entryNo = reader.int64().toBigInt();
                    break;
                case /* string objectId */ 2:
                    message.objectId = reader.string();
                    break;
                case /* ObjectType objectType */ 3:
                    message.objectType = reader.int32();
                    break;
                case /* string fromStatusId */ 4:
                    message.fromStatusId = reader.string();
                    break;
                case /* string toStatusId */ 5:
                    message.toStatusId = reader.string();
                    break;
                case /* string fromStatusName */ 6:
                    message.fromStatusName = reader.string();
                    break;
                case /* string toStatusName */ 7:
                    message.toStatusName = reader.string();
                    break;
                case /* string objectName */ 8:
                    message.objectName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusChangeInformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 entryNo = 1; */
        if (message.entryNo !== undefined)
            writer.tag(1, WireType.Varint).int64(message.entryNo);
        /* string objectId = 2; */
        if (message.objectId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.objectId);
        /* ObjectType objectType = 3; */
        if (message.objectType !== 0)
            writer.tag(3, WireType.Varint).int32(message.objectType);
        /* string fromStatusId = 4; */
        if (message.fromStatusId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fromStatusId);
        /* string toStatusId = 5; */
        if (message.toStatusId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.toStatusId);
        /* string fromStatusName = 6; */
        if (message.fromStatusName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fromStatusName);
        /* string toStatusName = 7; */
        if (message.toStatusName !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.toStatusName);
        /* string objectName = 8; */
        if (message.objectName !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.objectName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusChangeInformation
 */
export const StatusChangeInformation = new StatusChangeInformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusRequest$Type extends MessageType<DeleteStatusRequest> {
    constructor() {
        super("DeleteStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "statusId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusRequest>): DeleteStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusRequest): DeleteStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string statusId */ 2:
                    message.statusId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string statusId = 2; */
        if (message.statusId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.statusId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteStatusRequest
 */
export const DeleteStatusRequest = new DeleteStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusRequest$Type extends MessageType<GetStatusRequest> {
    constructor() {
        super("GetStatusRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetStatusRequest>): GetStatusRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusRequest): GetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusRequest
 */
export const GetStatusRequest = new GetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusReply$Type extends MessageType<GetStatusReply> {
    constructor() {
        super("GetStatusReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "status", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Status }
        ]);
    }
    create(value?: PartialMessage<GetStatusReply>): GetStatusReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusReply): GetStatusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated Status status */ 2:
                    message.status.push(Status.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated Status status = 2; */
        for (let i = 0; i < message.status.length; i++)
            Status.internalBinaryWrite(message.status[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusReply
 */
export const GetStatusReply = new GetStatusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusSavedEvent$Type extends MessageType<StatusSavedEvent> {
    constructor() {
        super("StatusSavedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StatusSavedEvent>): StatusSavedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusSavedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusSavedEvent): StatusSavedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* Status status */ 2:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusSavedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* Status status = 2; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusSavedEvent
 */
export const StatusSavedEvent = new StatusSavedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusChangedEvent$Type extends MessageType<StatusChangedEvent> {
    constructor() {
        super("StatusChangedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "statusChangeInformation", kind: "message", T: () => StatusChangeInformation }
        ]);
    }
    create(value?: PartialMessage<StatusChangedEvent>): StatusChangedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StatusChangedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusChangedEvent): StatusChangedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* StatusChangeInformation statusChangeInformation */ 2:
                    message.statusChangeInformation = StatusChangeInformation.internalBinaryRead(reader, reader.uint32(), options, message.statusChangeInformation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusChangedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StatusChangeInformation statusChangeInformation = 2; */
        if (message.statusChangeInformation)
            StatusChangeInformation.internalBinaryWrite(message.statusChangeInformation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusChangedEvent
 */
export const StatusChangedEvent = new StatusChangedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusDeletedEvent$Type extends MessageType<StatusDeletedEvent> {
    constructor() {
        super("StatusDeletedEvent", [
            { no: 1, name: "header", kind: "message", T: () => EventHeader },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StatusDeletedEvent>): StatusDeletedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<StatusDeletedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusDeletedEvent): StatusDeletedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* EventHeader header */ 1:
                    message.header = EventHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusDeletedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* EventHeader header = 1; */
        if (message.header)
            EventHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StatusDeletedEvent
 */
export const StatusDeletedEvent = new StatusDeletedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddStatusTransitionRuleRequest$Type extends MessageType<AddStatusTransitionRuleRequest> {
    constructor() {
        super("AddStatusTransitionRuleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "rule", kind: "message", T: () => StatusTransitionRule }
        ]);
    }
    create(value?: PartialMessage<AddStatusTransitionRuleRequest>): AddStatusTransitionRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<AddStatusTransitionRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddStatusTransitionRuleRequest): AddStatusTransitionRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* StatusTransitionRule rule */ 2:
                    message.rule = StatusTransitionRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddStatusTransitionRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StatusTransitionRule rule = 2; */
        if (message.rule)
            StatusTransitionRule.internalBinaryWrite(message.rule, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddStatusTransitionRuleRequest
 */
export const AddStatusTransitionRuleRequest = new AddStatusTransitionRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateStatusTransitionRuleRequest$Type extends MessageType<UpdateStatusTransitionRuleRequest> {
    constructor() {
        super("UpdateStatusTransitionRuleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "rule", kind: "message", T: () => StatusTransitionRule }
        ]);
    }
    create(value?: PartialMessage<UpdateStatusTransitionRuleRequest>): UpdateStatusTransitionRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateStatusTransitionRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateStatusTransitionRuleRequest): UpdateStatusTransitionRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* StatusTransitionRule rule */ 2:
                    message.rule = StatusTransitionRule.internalBinaryRead(reader, reader.uint32(), options, message.rule);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateStatusTransitionRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* StatusTransitionRule rule = 2; */
        if (message.rule)
            StatusTransitionRule.internalBinaryWrite(message.rule, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateStatusTransitionRuleRequest
 */
export const UpdateStatusTransitionRuleRequest = new UpdateStatusTransitionRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteStatusTransitionRuleRequest$Type extends MessageType<DeleteStatusTransitionRuleRequest> {
    constructor() {
        super("DeleteStatusTransitionRuleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "ruleId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteStatusTransitionRuleRequest>): DeleteStatusTransitionRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ruleId = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteStatusTransitionRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteStatusTransitionRuleRequest): DeleteStatusTransitionRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* string ruleId */ 2:
                    message.ruleId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteStatusTransitionRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string ruleId = 2; */
        if (message.ruleId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.ruleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteStatusTransitionRuleRequest
 */
export const DeleteStatusTransitionRuleRequest = new DeleteStatusTransitionRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusTransitionRuleRequest$Type extends MessageType<GetStatusTransitionRuleRequest> {
    constructor() {
        super("GetStatusTransitionRuleRequest", [
            { no: 1, name: "header", kind: "message", T: () => RequestHeader },
            { no: 2, name: "filters", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RequestFilter }
        ]);
    }
    create(value?: PartialMessage<GetStatusTransitionRuleRequest>): GetStatusTransitionRuleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.filters = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusTransitionRuleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusTransitionRuleRequest): GetStatusTransitionRuleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* RequestHeader header */ 1:
                    message.header = RequestHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated RequestFilter filters */ 2:
                    message.filters.push(RequestFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusTransitionRuleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* RequestHeader header = 1; */
        if (message.header)
            RequestHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated RequestFilter filters = 2; */
        for (let i = 0; i < message.filters.length; i++)
            RequestFilter.internalBinaryWrite(message.filters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusTransitionRuleRequest
 */
export const GetStatusTransitionRuleRequest = new GetStatusTransitionRuleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStatusTransitionRuleReply$Type extends MessageType<GetStatusTransitionRuleReply> {
    constructor() {
        super("GetStatusTransitionRuleReply", [
            { no: 1, name: "header", kind: "message", T: () => ReplyHeader },
            { no: 2, name: "rules", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StatusTransitionRule }
        ]);
    }
    create(value?: PartialMessage<GetStatusTransitionRuleReply>): GetStatusTransitionRuleReply {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rules = [];
        if (value !== undefined)
            reflectionMergePartial<GetStatusTransitionRuleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStatusTransitionRuleReply): GetStatusTransitionRuleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ReplyHeader header */ 1:
                    message.header = ReplyHeader.internalBinaryRead(reader, reader.uint32(), options, message.header);
                    break;
                case /* repeated StatusTransitionRule rules */ 2:
                    message.rules.push(StatusTransitionRule.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStatusTransitionRuleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ReplyHeader header = 1; */
        if (message.header)
            ReplyHeader.internalBinaryWrite(message.header, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated StatusTransitionRule rules = 2; */
        for (let i = 0; i < message.rules.length; i++)
            StatusTransitionRule.internalBinaryWrite(message.rules[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetStatusTransitionRuleReply
 */
export const GetStatusTransitionRuleReply = new GetStatusTransitionRuleReply$Type();
